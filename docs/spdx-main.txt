SPDXVersion: SPDX-2.1
DataLicense: CC0-1.0
SPDXID: SPDXRef-DOCUMENT
DocumentName: Crow_CPP_Template
DocumentNamespace: http://spdx.org/spdxdocs/spdx-v2.1-06b277ae-60f1-49a8-bd5f-86e9e8bba2aa
Creator: Person: Anonymous ()
Creator: Organization: Anonymous ()
Creator: Tool: reuse-6.2.0
Created: 2026-01-31T18:28:05Z
CreatorComment: <text>This document was created automatically using available reuse information consistent with REUSE.</text>
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-b77051a31b9af9d7a3d7dcd8b18988f1
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-8d9c1839150b7275ef8ed70f471832ed
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-997877e9497730ec2d82ec485acc1474
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-4507561f425b645ff578d2dae60a1674
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-3ddf9bbd2a7a3fb95164cf8d64a62b5d
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-4c850f738b1a8fcac63ec202d29f6db2
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-be8ef011922b327da12cc035c3a83dc8
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-21d8d67205da83e7440cfe9c8c7648e1
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-196562bf309bf22c3b5cc9534552f334
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-aac72e083b88222e3b23b6d409a7b58b
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-c9f12055ae2af043bb24f0e634511969
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-16729123b828bff03aab5c26f66774b5
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-125ea79a9c19f54fad42869e18300720
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-b290eb21d89748a6e20b32a97dcfcc37
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-4ba5edbb464648d726b957fd20f3c486
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-eff51a64ed7b15ae74591b405c14b213
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-e31eb5869ce3b16f54ec5bbf06c7fc50
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-fa0d352fdf77444f3fff8d9581d879fe
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-cb0a0a61c6464954a0c861bbc05cae06
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-a5dd71182f4dcfc0a1fe079af21104ef
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-57cf7d79fdc00f2ed6cf21a4ef5296cd
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-cdf5c6aa4a235aa53101b3f427393398
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-940635b69d00756c9f78f2f11a962770
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-ca39c80dc0b0aa8865357c4980380929
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-dc1d1dcce033c7869764cec192653a0e
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-c58f4247b911dcec0cfff0e0fdd50cf5
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-0d2f0b069838ea40379c6ffa9c6e85c4
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-c73fda6c08061fea9234775e6b9069a4
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-3309c83063d02ec2a0df69757682adde
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-0316045d7f769c7ac6fa05473e3a8a1c
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-83447446d2d86aab2197a1b8d46e1183
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-8d7d6fdc42939dc9edd823740625d4fd
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-2ce89b14de2fec49cfe9d70aba00e138
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-203df689a34d07eda55403469bfd4b68
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-f57667474205937f35aafe6727907697
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-d2e6e642baa504faf5b8e085d26de629
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-d8fcb5d13b3800d8c65f750b4ab7177c
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-b8e96d6d61a17df896bb04af300b83ab
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-d5bab7014b2caa0579ccecda09e08e06
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-e563b1c6ce4aa2fac7a07eea220a97dc
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-2f589d934febd238571a46221a894666
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-bbaad7783e05250d613e3fab42a921dd
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-ff07ef5e2a3010e0d5dc54d6c9ae161e
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-8be91e430c95a6486b89b45f5d74fbe1
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-5ee4663c69203ae89fd39375b72194d6
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-78a61165840d27428937df5e23fdffa0
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-cb8187aee7c42f40f636de29ad0f83c3
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-a9893024783af82d67ddb77c68411b0b
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-6bb3e06d2a7a810bbf44137fc7f07a4e
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-4037062a61e46def9f5938a27fab1a5e
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-b0e3969b7ad38254816dfc80a0fbbf28
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-d8861d8f73accd7d66fb8640eccb7558
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-ce03dab6c6280e1e5031273391ca8b6c
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-782ca15fecc8288cb115cb6d18f1da41
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-b9cdc1a480c66871a5aeb28372ca1e21
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-3065d373ebd61e3d0ab525ae91a230b7
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-39e5933c72f537cb1aee2802103df369
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-caca343608935f1506ee0790d3f7b8e6
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-c311b335d6a8ed3252103beed9c9e079
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-5a63591313e86ec50e4b7331e6f046bd
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-e4ff35d5930addf1530d8edcb0ed4389
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-d7cc306a91f4c71d66e6b81143cac554
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-60ed8a6bd0bbcdecffbc04f0c742bea2
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-799391d5153ae74b60645bbf5ff44368
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-3bfeac1ee1e55c49cd11a4283e47eda7
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-e4b9b5bb6c8f48ebe69474687f910d93
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-32b9720a593e0d232367820234be854e
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-a1b2e3cc2cff2229267b8525a6bc85df
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-81ddf74e94301a273ed3f25b147472aa
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-86c5f899cd897f9fd445bd861e02eed9
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-8a76baa8d2b42a8fe056f03ae0dd3095
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-d2083c0f3e33b3d9729aca5ea90faa8b
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-6f4f9df40d4bc98f230a2beb56899753
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-15a34575ec83f8fc1d89db6d63b3c539
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-ad5e1cf9bed9cff76fe63ac850777dca
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-6a56985bc0aa7f302363d54ac5f8084c
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-071e207ada90f05863a723896381e2e6
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-c4588efdd0fdd4a2bf1f64c00548e533
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-35d535f35588ccec87b5a29e4edd01b0
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-6e72c27a4eb78a3de2ab9d73d3df51e1
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-c1b33291eacda023f07772c5509f4c74
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-6021d6360e9f2418f11d09c687535a17
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-027002965d2e5ec1903c8ae1938d8530
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-f0364c8585346583ff9df0797b2b3d4e
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-023bcc14e5802ab957e4939c0ba55baf
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-aafc4d56dac194c339961cd83f2ed81d
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-061520c6defebf77bfd6bae80fc8c89a
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-cf15434e16a95a07084fb52ac162b485
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-9b9071a3cf8daca2293581d2d206030a
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-bbfe04c97e7d4ba3024ce3d874f98ad8
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-014c274c78572f7f869ef513b11c0ef5
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-c704ce5c4fafcf2760a2a96d8fecb2d4
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-d7f0aa7aedeef4c4714be220704701ee
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-2a8da077bd5e5dc59a2591b05267009b
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-93897d086c4f5e2e1bef4e50956e2376
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-1c081c12a10a30589cc2980600e78ef8
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-73eb80171923bde50a2ab1c71df66d61
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-da5a1afe304c3bced164fd5660a4f61e
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-1de3315b4848f2e554fa18bb210e089e
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-b96e08c25d313b57d0924a3341e7305c
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-3deddaf82d6ef800c616952f0d141b20
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-4b165aabd4d2f106a64f9c4961744af7
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-b36a65341b0be3fad0910d9d2dadfdb2
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-a6a1e72bcbe014c5ce845da3b9b77551
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-b28d316f1e3c9355777609bdb5f0153d
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-9aa3973c45183dc340a3def680cb33bf
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-c4d390c7ace8c0d0b041c2580d3f58a4
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-e9e321d3000abaf4b1a0b32e776a63aa
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-d2732f0b27c53dd9290011e86c374c24
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-3dc12b34bc1ed919cc77d32d883ad99d
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-6335d0afe626c95f55fbfe25d81529b0
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-6b4512ed73b8fa7eb0cb1234ce5d7f96
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-6de046d677e15986b2d20d28feb75d71
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-65b97baac3d02bb51860b01f7267df68
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-dd9df9d094d51936ae42b4c7b14b7080
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-8df3bf4fcbbb59234f65dff4baac893a
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-5837e1894fae94f7153ea277c18cf5aa
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-81ffc90806996126b41acfe49c7e160b
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-f1f2c785d7a15ddc3a9fca18139120e4
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-a81b99f8e6b82b89e54d6681d743436e
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-b13168ccae4ebf1c283905bb2fb80db1
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-736047b985f750bdf99a723f1b84ad92
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-1a9fe01352594c4107738a745ea67955
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-4e5075349bad5d82a53a5b4b4aaa1506
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-9cf6ad69d966e580fb674cd371533605
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-163a4d0bc8cabacd34018c48d3a09d2e
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-75a8329d8c89793a2261efb1c1cef3e6
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-4f3338f309a6c503ee97bf16fa21511f
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-49578711dcfa6361f01f426565fa883a
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-224af8da227941b508cc027e46345c2d
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-81fb5daf5c6e205440d372148f2b5d22
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-56e22a0f77d5270591fa3c01a170bf3b
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-1aea286ba553e8dc6738c9586d501fd6
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-6372529ffe356b9401b94b9a2fe8e85d
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-7417e54b92c23b1a1bbcd0c42344f6fb
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-ba176a532da27a77a65f5ecfae672af3
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-93ba4104a641e00ddad18d632594b44d
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-1ed3b27b98647cfe19ca85d78d41f1a6
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-1960a182578fc2e8aa78d35acda9c7e6
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-b571c112635d627e6a698eb233953bfe
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-f59fcc5326862419cc1412815392ae2f
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-d78f1418a5acbaa56380e5b3184721d7
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-5eb1a2ef06611e66ccb61e154b23baa1
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-3fc748a588ff670f5900eb255ecdabc9
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-03e2e000c9caa5ea9662dc38cd0a084e
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-cbfc0cb21354808975107499e3b09402
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-69382af10da40683523d2b7b784a83f3
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-07c3573450de4fb0780deb0d2745be85
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-fb44ea4818a310620386b5bbd2cdbbf4
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-5caf465a694686dc6ac024d49a35a4c0
Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-9f910f95ab535fab85e984094b1031e1

FileName: ./.github/actions/doctoc/README.md
SPDXID: SPDXRef-b77051a31b9af9d7a3d7dcd8b18988f1
FileChecksum: SHA1: 222f7998324e6ea8517f6f768d7d210ad3a52d73
LicenseConcluded: NOASSERTION
FileCopyrightText: <text>Copyright 2013 Thorsten Lorenz.
Copyright (C) 2024 ZHENG Robert</text>

FileName: ./.github/actions/doctoc/action.yml
SPDXID: SPDXRef-8d9c1839150b7275ef8ed70f471832ed
FileChecksum: SHA1: 977cc42f5ce3999d112021ac8c6f4bf98fc918b7
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./.github/actions/doctoc/dist/index.js
SPDXID: SPDXRef-997877e9497730ec2d82ec485acc1474
FileChecksum: SHA1: b6e4af4ed3a1e1b1f26d655dea3cfb6ed3ea1d7d
LicenseConcluded: NOASSERTION
FileCopyrightText: <text>Copyright 2010-2013 Sami Samhuri <sami@samhuri.net>
Copyright (C) 2014-2015 Jon Schlinkert.
¬© 2017 azu
¬© ","COPY":"¬©","Cacute":"ƒÜ","Cap":"‚ãí","CapitalDifferentialD":"‚ÖÖ","Cayleys":"‚Ñ≠","Ccaron":"ƒå","Ccedi":"√á","Ccedil":"√á","Ccirc":"ƒà","Cconint":"‚à∞","Cdot":"ƒä","Cedilla":"¬∏","CenterDot":"¬∑","Cfr":"‚Ñ≠","Chi":"Œß","CircleDot":"‚äô","CircleMinus":"‚äñ","CirclePlus":"‚äï","CircleTimes":"‚äó","ClockwiseContourIntegral":"‚à≤","CloseCurlyDoubleQuote":"‚Äù","CloseCurlyQuote":"‚Äô","Colon":"‚à∑","Colone":"‚©¥","Congruent":"‚â°","Conint":"‚àØ","ContourIntegral":"‚àÆ","Copf":"‚ÑÇ","Coproduct":"‚àê","CounterClockwiseContourIntegral":"‚à≥","Cross":"‚®Ø","Cscr":"ùíû","Cup":"‚ãì","CupCap":"‚âç","DD":"‚ÖÖ","DDotrahd":"‚§ë","DJcy":"–Ç","DScy":"–Ö","DZcy":"–è","Dagger":"‚Ä°","Darr":"‚Ü°","Dashv":"‚´§","Dcaron":"ƒé","Dcy":"–î","Del":"‚àá","Delta":"Œî","Dfr":"ùîá","DiacriticalAcute":"¬¥","DiacriticalDot":"Àô","DiacriticalDoubleAcute":"Àù","DiacriticalGrave":"`","DiacriticalTilde":"Àú","Diamond":"‚ãÑ","DifferentialD":"‚ÖÜ","Dopf":"ùîª","Dot":"¬®","DotDot":"‚Éú","DotEqual":"‚âê","DoubleContourIntegral":"‚àØ","DoubleDot":"¬®","DoubleDownArrow":"‚áì","DoubleLeftArrow":"‚áê","DoubleLeftRightArrow":"‚áî","DoubleLeftTee":"‚´§","DoubleLongLeftArrow":"‚ü∏","DoubleLongLeftRightArrow":"‚ü∫","DoubleLongRightArrow":"‚üπ","DoubleRightArrow":"‚áí","DoubleRightTee":"‚ä®","DoubleUpArrow":"‚áë","DoubleUpDownArrow":"‚áï","DoubleVerticalBar":"‚à•","DownArrow":"‚Üì","DownArrowBar":"‚§ì","DownArrowUpArrow":"‚áµ","DownBreve":"Ãë","DownLeftRightVector":"‚•ê","DownLeftTeeVector":"‚•û","DownLeftVector":"‚ÜΩ","DownLeftVectorBar":"‚•ñ","DownRightTeeVector":"‚•ü","DownRightVector":"‚áÅ","DownRightVectorBar":"‚•ó","DownTee":"‚ä§","DownTeeArrow":"‚Üß","Downarrow":"‚áì","Dscr":"ùíü","Dstrok":"ƒê","ENG":"≈ä","ET":"√ê","ETH":"√ê","Eacut":"√â","Eacute":"√â","Ecaron":"ƒö","Ecir":"√ä","Ecirc":"√ä","Ecy":"–≠","Edot":"ƒñ","Efr":"ùîà","Egrav":"√à","Egrave":"√à","Element":"‚àà","Emacr":"ƒí","EmptySmallSquare":"‚óª","EmptyVerySmallSquare":"‚ñ´","Eogon":"ƒò","Eopf":"ùîº","Epsilon":"Œï","Equal":"‚©µ","EqualTilde":"‚âÇ","Equilibrium":"‚áå","Escr":"‚Ñ∞","Esim":"‚©≥","Eta":"Œó","Eum":"√ã","Euml":"√ã","Exists":"‚àÉ","ExponentialE":"‚Öá","Fcy":"–§","Ffr":"ùîâ","FilledSmallSquare":"‚óº","FilledVerySmallSquare":"‚ñ™","Fopf":"ùîΩ","ForAll":"‚àÄ","Fouriertrf":"‚Ñ±","Fscr":"‚Ñ±","GJcy":"–É","G":">","GT":">","Gamma":"Œì","Gammad":"œú","Gbreve":"ƒû","Gcedil":"ƒ¢","Gcirc":"ƒú","Gcy":"–ì","Gdot":"ƒ†","Gfr":"ùîä","Gg":"‚ãô","Gopf":"ùîæ","GreaterEqual":"‚â•","GreaterEqualLess":"‚ãõ","GreaterFullEqual":"‚âß","GreaterGreater":"‚™¢","GreaterLess":"‚â∑","GreaterSlantEqual":"‚©æ","GreaterTilde":"‚â≥","Gscr":"ùí¢","Gt":"‚â´","HARDcy":"–™","Hacek":"Àá","Hat":"^","Hcirc":"ƒ§","Hfr":"‚Ñå","HilbertSpace":"‚Ñã","Hopf":"‚Ñç","HorizontalLine":"‚îÄ","Hscr":"‚Ñã","Hstrok":"ƒ¶","HumpDownHump":"‚âé","HumpEqual":"‚âè","IEcy":"–ï","IJlig":"ƒ≤","IOcy":"–Å","Iacut":"√ç","Iacute":"√ç","Icir":"√é","Icirc":"√é","Icy":"–ò","Idot":"ƒ∞","Ifr":"‚Ñë","Igrav":"√å","Igrave":"√å","Im":"‚Ñë","Imacr":"ƒ™","ImaginaryI":"‚Öà","Implies":"‚áí","Int":"‚à¨","Integral":"‚à´","Intersection":"‚ãÇ","InvisibleComma":"‚Å£","InvisibleTimes":"‚Å¢","Iogon":"ƒÆ","Iopf":"ùïÄ","Iota":"Œô","Iscr":"‚Ñê","Itilde":"ƒ®","Iukcy":"–Ü","Ium":"√è","Iuml":"√è","Jcirc":"ƒ¥","Jcy":"–ô","Jfr":"ùîç","Jopf":"ùïÅ","Jscr":"ùí•","Jsercy":"–à","Jukcy":"–Ñ","KHcy":"–•","KJcy":"–å","Kappa":"Œö","Kcedil":"ƒ∂","Kcy":"–ö","Kfr":"ùîé","Kopf":"ùïÇ","Kscr":"ùí¶","LJcy":"–â","L":"<","LT":"<","Lacute":"ƒπ","Lambda":"Œõ","Lang":"‚ü™","Laplacetrf":"‚Ñí","Larr":"‚Üû","Lcaron":"ƒΩ","Lcedil":"ƒª","Lcy":"–õ","LeftAngleBracket":"‚ü®","LeftArrow":"‚Üê","LeftArrowBar":"‚á§","LeftArrowRightArrow":"‚áÜ","LeftCeiling":"‚åà","LeftDoubleBracket":"‚ü¶","LeftDownTeeVector":"‚•°","LeftDownVector":"‚áÉ","LeftDownVectorBar":"‚•ô","LeftFloor":"‚åä","LeftRightArrow":"‚Üî","LeftRightVector":"‚•é","LeftTee":"‚ä£","LeftTeeArrow":"‚Ü§","LeftTeeVector":"‚•ö","LeftTriangle":"‚ä≤","LeftTriangleBar":"‚ßè","LeftTriangleEqual":"‚ä¥","LeftUpDownVector":"‚•ë","LeftUpTeeVector":"‚•†","LeftUpVector":"‚Üø","LeftUpVectorBar":"‚•ò","LeftVector":"‚Üº","LeftVectorBar":"‚•í","Leftarrow":"‚áê","Leftrightarrow":"‚áî","LessEqualGreater":"‚ãö","LessFullEqual":"‚â¶","LessGreater":"‚â∂","LessLess":"‚™°","LessSlantEqual":"‚©Ω","LessTilde":"‚â≤","Lfr":"ùîè","Ll":"‚ãò","Lleftarrow":"‚áö","Lmidot":"ƒø","LongLeftArrow":"‚üµ","LongLeftRightArrow":"‚ü∑","LongRightArrow":"‚ü∂","Longleftarrow":"‚ü∏","Longleftrightarrow":"‚ü∫","Longrightarrow":"‚üπ","Lopf":"ùïÉ","LowerLeftArrow":"‚Üô","LowerRightArrow":"‚Üò","Lscr":"‚Ñí","Lsh":"‚Ü∞","Lstrok":"≈Å","Lt":"‚â™","Map":"‚§Ö","Mcy":"–ú","MediumSpace":"‚Åü","Mellintrf":"‚Ñ≥","Mfr":"ùîê","MinusPlus":"‚àì","Mopf":"ùïÑ","Mscr":"‚Ñ≥","Mu":"Œú","NJcy":"–ä","Nacute":"≈É","Ncaron":"≈á","Ncedil":"≈Ö","Ncy":"–ù","NegativeMediumSpace":"‚Äã","NegativeThickSpace":"‚Äã","NegativeThinSpace":"‚Äã","NegativeVeryThinSpace":"‚Äã","NestedGreaterGreater":"‚â´","NestedLessLess":"‚â™","NewLine":"\\n","Nfr":"ùîë","NoBreak":"‚Å†","NonBreakingSpace":"¬†","Nopf":"‚Ñï","Not":"‚´¨","NotCongruent":"‚â¢","NotCupCap":"‚â≠","NotDoubleVerticalBar":"‚à¶","NotElement":"‚àâ","NotEqual":"‚â†","NotEqualTilde":"‚âÇÃ∏","NotExists":"‚àÑ","NotGreater":"‚âØ","NotGreaterEqual":"‚â±","NotGreaterFullEqual":"‚âßÃ∏","NotGreaterGreater":"‚â´Ã∏","NotGreaterLess":"‚âπ","NotGreaterSlantEqual":"‚©æÃ∏","NotGreaterTilde":"‚âµ","NotHumpDownHump":"‚âéÃ∏","NotHumpEqual":"‚âèÃ∏","NotLeftTriangle":"‚ã™","NotLeftTriangleBar":"‚ßèÃ∏","NotLeftTriangleEqual":"‚ã¨","NotLess":"‚âÆ","NotLessEqual":"‚â∞","NotLessGreater":"‚â∏","NotLessLess":"‚â™Ã∏","NotLessSlantEqual":"‚©ΩÃ∏","NotLessTilde":"‚â¥","NotNestedGreaterGreater":"‚™¢Ã∏","NotNestedLessLess":"‚™°Ã∏","NotPrecedes":"‚äÄ","NotPrecedesEqual":"‚™ØÃ∏","NotPrecedesSlantEqual":"‚ã†","NotReverseElement":"‚àå","NotRightTriangle":"‚ã´","NotRightTriangleBar":"‚ßêÃ∏","NotRightTriangleEqual":"‚ã≠","NotSquareSubset":"‚äèÃ∏","NotSquareSubsetEqual":"‚ã¢","NotSquareSuperset":"‚äêÃ∏","NotSquareSupersetEqual":"‚ã£","NotSubset":"‚äÇ‚Éí","NotSubsetEqual":"‚äà","NotSucceeds":"‚äÅ","NotSucceedsEqual":"‚™∞Ã∏","NotSucceedsSlantEqual":"‚ã°","NotSucceedsTilde":"‚âøÃ∏","NotSuperset":"‚äÉ‚Éí","NotSupersetEqual":"‚äâ","NotTilde":"‚âÅ","NotTildeEqual":"‚âÑ","NotTildeFullEqual":"‚âá","NotTildeTilde":"‚ââ","NotVerticalBar":"‚à§","Nscr":"ùí©","Ntild":"√ë","Ntilde":"√ë","Nu":"Œù","OElig":"≈í","Oacut":"√ì","Oacute":"√ì","Ocir":"√î","Ocirc":"√î","Ocy":"–û","Odblac":"≈ê","Ofr":"ùîí","Ograv":"√í","Ograve":"√í","Omacr":"≈å","Omega":"Œ©","Omicron":"Œü","Oopf":"ùïÜ","OpenCurlyDoubleQuote":"‚Äú","OpenCurlyQuote":"‚Äò","Or":"‚©î","Oscr":"ùí™","Oslas":"√ò","Oslash":"√ò","Otild":"√ï","Otilde":"√ï","Otimes":"‚®∑","Oum":"√ñ","Ouml":"√ñ","OverBar":"‚Äæ","OverBrace":"‚èû","OverBracket":"‚é¥","OverParenthesis":"‚èú","PartialD":"‚àÇ","Pcy":"–ü","Pfr":"ùîì","Phi":"Œ¶","Pi":"Œ†","PlusMinus":"¬±","Poincareplane":"‚Ñå","Popf":"‚Ñô","Pr":"‚™ª","Precedes":"‚â∫","PrecedesEqual":"‚™Ø","PrecedesSlantEqual":"‚âº","PrecedesTilde":"‚âæ","Prime":"‚Ä≥","Product":"‚àè","Proportion":"‚à∑","Proportional":"‚àù","Pscr":"ùí´","Psi":"Œ®","QUO":"\\"","QUOT":"\\"","Qfr":"ùîî","Qopf":"‚Ñö","Qscr":"ùí¨","RBarr":"‚§ê","RE":"¬Æ","REG":"¬Æ","Racute":"≈î","Rang":"‚ü´","Rarr":"‚Ü†","Rarrtl":"‚§ñ","Rcaron":"≈ò","Rcedil":"≈ñ","Rcy":"–†","Re":"‚Ñú","ReverseElement":"‚àã","ReverseEquilibrium":"‚áã","ReverseUpEquilibrium":"‚•Ø","Rfr":"‚Ñú","Rho":"Œ°","RightAngleBracket":"‚ü©","RightArrow":"‚Üí","RightArrowBar":"‚á•","RightArrowLeftArrow":"‚áÑ","RightCeiling":"‚åâ","RightDoubleBracket":"‚üß","RightDownTeeVector":"‚•ù","RightDownVector":"‚áÇ","RightDownVectorBar":"‚•ï","RightFloor":"‚åã","RightTee":"‚ä¢","RightTeeArrow":"‚Ü¶","RightTeeVector":"‚•õ","RightTriangle":"‚ä≥","RightTriangleBar":"‚ßê","RightTriangleEqual":"‚äµ","RightUpDownVector":"‚•è","RightUpTeeVector":"‚•ú","RightUpVector":"‚Üæ","RightUpVectorBar":"‚•î","RightVector":"‚áÄ","RightVectorBar":"‚•ì","Rightarrow":"‚áí","Ropf":"‚Ñù","RoundImplies":"‚•∞","Rrightarrow":"‚áõ","Rscr":"‚Ñõ","Rsh":"‚Ü±","RuleDelayed":"‚ß¥","SHCHcy":"–©","SHcy":"–®","SOFTcy":"–¨","Sacute":"≈ö","Sc":"‚™º","Scaron":"≈†","Scedil":"≈û","Scirc":"≈ú","Scy":"–°","Sfr":"ùîñ","ShortDownArrow":"‚Üì","ShortLeftArrow":"‚Üê","ShortRightArrow":"‚Üí","ShortUpArrow":"‚Üë","Sigma":"Œ£","SmallCircle":"‚àò","Sopf":"ùïä","Sqrt":"‚àö","Square":"‚ñ°","SquareIntersection":"‚äì","SquareSubset":"‚äè","SquareSubsetEqual":"‚äë","SquareSuperset":"‚äê","SquareSupersetEqual":"‚äí","SquareUnion":"‚äî","Sscr":"ùíÆ","Star":"‚ãÜ","Sub":"‚ãê","Subset":"‚ãê","SubsetEqual":"‚äÜ","Succeeds":"‚âª","SucceedsEqual":"‚™∞","SucceedsSlantEqual":"‚âΩ","SucceedsTilde":"‚âø","SuchThat":"‚àã","Sum":"‚àë","Sup":"‚ãë","Superset":"‚äÉ","SupersetEqual":"‚äá","Supset":"‚ãë","THOR":"√û","THORN":"√û","TRADE":"‚Ñ¢","TSHcy":"–ã","TScy":"–¶","Tab":"\\t","Tau":"Œ§","Tcaron":"≈§","Tcedil":"≈¢","Tcy":"–¢","Tfr":"ùîó","Therefore":"‚à¥","Theta":"Œò","ThickSpace":"‚Åü‚Ää","ThinSpace":"‚Äâ","Tilde":"‚àº","TildeEqual":"‚âÉ","TildeFullEqual":"‚âÖ","TildeTilde":"‚âà","Topf":"ùïã","TripleDot":"‚Éõ","Tscr":"ùíØ","Tstrok":"≈¶","Uacut":"√ö","Uacute":"√ö","Uarr":"‚Üü","Uarrocir":"‚•â","Ubrcy":"–é","Ubreve":"≈¨","Ucir":"√õ","Ucirc":"√õ","Ucy":"–£","Udblac":"≈∞","Ufr":"ùîò","Ugrav":"√ô","Ugrave":"√ô","Umacr":"≈™","UnderBar":"_","UnderBrace":"‚èü","UnderBracket":"‚éµ","UnderParenthesis":"‚èù","Union":"‚ãÉ","UnionPlus":"‚äé","Uogon":"≈≤","Uopf":"ùïå","UpArrow":"‚Üë","UpArrowBar":"‚§í","UpArrowDownArrow":"‚áÖ","UpDownArrow":"‚Üï","UpEquilibrium":"‚•Æ","UpTee":"‚ä•","UpTeeArrow":"‚Ü•","Uparrow":"‚áë","Updownarrow":"‚áï","UpperLeftArrow":"‚Üñ","UpperRightArrow":"‚Üó","Upsi":"œí","Upsilon":"Œ•","Uring":"≈Æ","Uscr":"ùí∞","Utilde":"≈®","Uum":"√ú","Uuml":"√ú","VDash":"‚ä´","Vbar":"‚´´","Vcy":"–í","Vdash":"‚ä©","Vdashl":"‚´¶","Vee":"‚ãÅ","Verbar":"‚Äñ","Vert":"‚Äñ","VerticalBar":"‚à£","VerticalLine":"|","VerticalSeparator":"‚ùò","VerticalTilde":"‚âÄ","VeryThinSpace":"‚Ää","Vfr":"ùîô","Vopf":"ùïç","Vscr":"ùí±","Vvdash":"‚ä™","Wcirc":"≈¥","Wedge":"‚ãÄ","Wfr":"ùîö","Wopf":"ùïé","Wscr":"ùí≤","Xfr":"ùîõ","Xi":"Œû","Xopf":"ùïè","Xscr":"ùí≥","YAcy":"–Ø","YIcy":"–á","YUcy":"–Æ","Yacut":"√ù","Yacute":"√ù","Ycirc":"≈∂","Ycy":"–´","Yfr":"ùîú","Yopf":"ùïê","Yscr":"ùí¥","Yuml":"≈∏","ZHcy":"–ñ","Zacute":"≈π","Zcaron":"≈Ω","Zcy":"–ó","Zdot":"≈ª","ZeroWidthSpace":"‚Äã","Zeta":"Œñ","Zfr":"‚Ñ®","Zopf":"‚Ñ§","Zscr":"ùíµ","aacut":"√°","aacute":"√°","abreve":"ƒÉ","ac":"‚àæ","acE":"‚àæÃ≥","acd":"‚àø","acir":"√¢","acirc":"√¢","acut":"¬¥","acute":"¬¥","acy":"–∞","aeli":"√¶","aelig":"√¶","af":"‚Å°","afr":"ùîû","agrav":"√†","agrave":"√†","alefsym":"‚Ñµ","aleph":"‚Ñµ","alpha":"Œ±","amacr":"ƒÅ","amalg":"‚®ø","am":"&","amp":"&","and":"‚àß","andand":"‚©ï","andd":"‚©ú","andslope":"‚©ò","andv":"‚©ö","ang":"‚à†","ange":"‚¶§","angle":"‚à†","angmsd":"‚à°","angmsdaa":"‚¶®","angmsdab":"‚¶©","angmsdac":"‚¶™","angmsdad":"‚¶´","angmsdae":"‚¶¨","angmsdaf":"‚¶≠","angmsdag":"‚¶Æ","angmsdah":"‚¶Ø","angrt":"‚àü","angrtvb":"‚äæ","angrtvbd":"‚¶ù","angsph":"‚à¢","angst":"√Ö","angzarr":"‚çº","aogon":"ƒÖ","aopf":"ùïí","ap":"‚âà","apE":"‚©∞","apacir":"‚©Ø","ape":"‚âä","apid":"‚âã","apos":"\'","approx":"‚âà","approxeq":"‚âä","arin":"√•","aring":"√•","ascr":"ùí∂","ast":"*","asymp":"‚âà","asympeq":"‚âç","atild":"√£","atilde":"√£","aum":"√§","auml":"√§","awconint":"‚à≥","awint":"‚®ë","bNot":"‚´≠","backcong":"‚âå","backepsilon":"œ∂","backprime":"‚Äµ","backsim":"‚àΩ","backsimeq":"‚ãç","barvee":"‚äΩ","barwed":"‚åÖ","barwedge":"‚åÖ","bbrk":"‚éµ","bbrktbrk":"‚é∂","bcong":"‚âå","bcy":"–±","bdquo":"‚Äû","becaus":"‚àµ","because":"‚àµ","bemptyv":"‚¶∞","bepsi":"œ∂","bernou":"‚Ñ¨","beta":"Œ≤","beth":"‚Ñ∂","between":"‚â¨","bfr":"ùîü","bigcap":"‚ãÇ","bigcirc":"‚óØ","bigcup":"‚ãÉ","bigodot":"‚®Ä","bigoplus":"‚®Å","bigotimes":"‚®Ç","bigsqcup":"‚®Ü","bigstar":"‚òÖ","bigtriangledown":"‚ñΩ","bigtriangleup":"‚ñ≥","biguplus":"‚®Ñ","bigvee":"‚ãÅ","bigwedge":"‚ãÄ","bkarow":"‚§ç","blacklozenge":"‚ß´","blacksquare":"‚ñ™","blacktriangle":"‚ñ¥","blacktriangledown":"‚ñæ","blacktriangleleft":"‚óÇ","blacktriangleright":"‚ñ∏","blank":"‚ê£","blk12":"‚ñí","blk14":"‚ñë","blk34":"‚ñì","block":"‚ñà","bne":"=‚É•","bnequiv":"‚â°‚É•","bnot":"‚åê","bopf":"ùïì","bot":"‚ä•","bottom":"‚ä•","bowtie":"‚ãà","boxDL":"‚ïó","boxDR":"‚ïî","boxDl":"‚ïñ","boxDr":"‚ïì","boxH":"‚ïê","boxHD":"‚ï¶","boxHU":"‚ï©","boxHd":"‚ï§","boxHu":"‚ïß","boxUL":"‚ïù","boxUR":"‚ïö","boxUl":"‚ïú","boxUr":"‚ïô","boxV":"‚ïë","boxVH":"‚ï¨","boxVL":"‚ï£","boxVR":"‚ï†","boxVh":"‚ï´","boxVl":"‚ï¢","boxVr":"‚ïü","boxbox":"‚ßâ","boxdL":"‚ïï","boxdR":"‚ïí","boxdl":"‚îê","boxdr":"‚îå","boxh":"‚îÄ","boxhD":"‚ï•","boxhU":"‚ï®","boxhd":"‚î¨","boxhu":"‚î¥","boxminus":"‚äü","boxplus":"‚äû","boxtimes":"‚ä†","boxuL":"‚ïõ","boxuR":"‚ïò","boxul":"‚îò","boxur":"‚îî","boxv":"‚îÇ","boxvH":"‚ï™","boxvL":"‚ï°","boxvR":"‚ïû","boxvh":"‚îº","boxvl":"‚î§","boxvr":"‚îú","bprime":"‚Äµ","breve":"Àò","brvba":"¬¶","brvbar":"¬¶","bscr":"ùí∑","bsemi":"‚Åè","bsim":"‚àΩ","bsime":"‚ãç","bsol":"\\\\","bsolb":"‚ßÖ","bsolhsub":"‚üà","bull":"‚Ä¢","bullet":"‚Ä¢","bump":"‚âé","bumpE":"‚™Æ","bumpe":"‚âè","bumpeq":"‚âè","cacute":"ƒá","cap":"‚à©","capand":"‚©Ñ","capbrcup":"‚©â","capcap":"‚©ã","capcup":"‚©á","capdot":"‚©Ä","caps":"‚à©Ô∏Ä","caret":"‚ÅÅ","caron":"Àá","ccaps":"‚©ç","ccaron":"ƒç","ccedi":"√ß","ccedil":"√ß","ccirc":"ƒâ","ccups":"‚©å","ccupssm":"‚©ê","cdot":"ƒã","cedi":"¬∏","cedil":"¬∏","cemptyv":"‚¶≤","cen":"¬¢","cent":"¬¢","centerdot":"¬∑","cfr":"ùî†","chcy":"—á","check":"‚úì","checkmark":"‚úì","chi":"œá","cir":"‚óã","cirE":"‚ßÉ","circ":"ÀÜ","circeq":"‚âó","circlearrowleft":"‚Ü∫","circlearrowright":"‚Üª","circledR":"¬Æ","circledS":"‚ìà","circledast":"‚äõ","circledcirc":"‚äö","circleddash":"‚äù","cire":"‚âó","cirfnint":"‚®ê","cirmid":"‚´Ø","cirscir":"‚ßÇ","clubs":"‚ô£","clubsuit":"‚ô£","colon":":","colone":"‚âî","coloneq":"‚âî","comma":",","commat":"@","comp":"‚àÅ","compfn":"‚àò","complement":"‚àÅ","complexes":"‚ÑÇ","cong":"‚âÖ","congdot":"‚©≠","conint":"‚àÆ","copf":"ùïî","coprod":"‚àê","cop":"¬©","copy":"¬©","copysr":"‚Ñó","crarr":"‚Üµ","cross":"‚úó","cscr":"ùí∏","csub":"‚´è","csube":"‚´ë","csup":"‚´ê","csupe":"‚´í","ctdot":"‚ãØ","cudarrl":"‚§∏","cudarrr":"‚§µ","cuepr":"‚ãû","cuesc":"‚ãü","cularr":"‚Ü∂","cularrp":"‚§Ω","cup":"‚à™","cupbrcap":"‚©à","cupcap":"‚©Ü","cupcup":"‚©ä","cupdot":"‚äç","cupor":"‚©Ö","cups":"‚à™Ô∏Ä","curarr":"‚Ü∑","curarrm":"‚§º","curlyeqprec":"‚ãû","curlyeqsucc":"‚ãü","curlyvee":"‚ãé","curlywedge":"‚ãè","curre":"¬§","curren":"¬§","curvearrowleft":"‚Ü∂","curvearrowright":"‚Ü∑","cuvee":"‚ãé","cuwed":"‚ãè","cwconint":"‚à≤","cwint":"‚à±","cylcty":"‚å≠","dArr":"‚áì","dHar":"‚••","dagger":"‚Ä†","daleth":"‚Ñ∏","darr":"‚Üì","dash":"‚Äê","dashv":"‚ä£","dbkarow":"‚§è","dblac":"Àù","dcaron":"ƒè","dcy":"–¥","dd":"‚ÖÜ","ddagger":"‚Ä°","ddarr":"‚áä","ddotseq":"‚©∑","de":"¬∞","deg":"¬∞","delta":"Œ¥","demptyv":"‚¶±","dfisht":"‚•ø","dfr":"ùî°","dharl":"‚áÉ","dharr":"‚áÇ","diam":"‚ãÑ","diamond":"‚ãÑ","diamondsuit":"‚ô¶","diams":"‚ô¶","die":"¬®","digamma":"œù","disin":"‚ã≤","div":"√∑","divid":"√∑","divide":"√∑","divideontimes":"‚ãá","divonx":"‚ãá","djcy":"—í","dlcorn":"‚åû","dlcrop":"‚åç","dollar":"$","dopf":"ùïï","dot":"Àô","doteq":"‚âê","doteqdot":"‚âë","dotminus":"‚à∏","dotplus":"‚àî","dotsquare":"‚ä°","doublebarwedge":"‚åÜ","downarrow":"‚Üì","downdownarrows":"‚áä","downharpoonleft":"‚áÉ","downharpoonright":"‚áÇ","drbkarow":"‚§ê","drcorn":"‚åü","drcrop":"‚åå","dscr":"ùíπ","dscy":"—ï","dsol":"‚ß∂","dstrok":"ƒë","dtdot":"‚ã±","dtri":"‚ñø","dtrif":"‚ñæ","duarr":"‚áµ","duhar":"‚•Ø","dwangle":"‚¶¶","dzcy":"—ü","dzigrarr":"‚üø","eDDot":"‚©∑","eDot":"‚âë","eacut":"√©","eacute":"√©","easter":"‚©Æ","ecaron":"ƒõ","ecir":"√™","ecirc":"√™","ecolon":"‚âï","ecy":"—ç","edot":"ƒó","ee":"‚Öá","efDot":"‚âí","efr":"ùî¢","eg":"‚™ö","egrav":"√®","egrave":"√®","egs":"‚™ñ","egsdot":"‚™ò","el":"‚™ô","elinters":"‚èß","ell":"‚Ñì","els":"‚™ï","elsdot":"‚™ó","emacr":"ƒì","empty":"‚àÖ","emptyset":"‚àÖ","emptyv":"‚àÖ","emsp13":"‚ÄÑ","emsp14":"‚ÄÖ","emsp":"‚ÄÉ","eng":"≈ã","ensp":"‚ÄÇ","eogon":"ƒô","eopf":"ùïñ","epar":"‚ãï","eparsl":"‚ß£","eplus":"‚©±","epsi":"Œµ","epsilon":"Œµ","epsiv":"œµ","eqcirc":"‚âñ","eqcolon":"‚âï","eqsim":"‚âÇ","eqslantgtr":"‚™ñ","eqslantless":"‚™ï","equals":"=","equest":"‚âü","equiv":"‚â°","equivDD":"‚©∏","eqvparsl":"‚ß•","erDot":"‚âì","erarr":"‚•±","escr":"‚ÑØ","esdot":"‚âê","esim":"‚âÇ","eta":"Œ∑","et":"√∞","eth":"√∞","eum":"√´","euml":"√´","euro":"‚Ç¨","excl":"!","exist":"‚àÉ","expectation":"‚Ñ∞","exponentiale":"‚Öá","fallingdotseq":"‚âí","fcy":"—Ñ","female":"‚ôÄ","ffilig":"Ô¨É","fflig":"Ô¨Ä","ffllig":"Ô¨Ñ","ffr":"ùî£","filig":"Ô¨Å","fjlig":"fj","flat":"‚ô≠","fllig":"Ô¨Ç","fltns":"‚ñ±","fnof":"∆í","fopf":"ùïó","forall":"‚àÄ","fork":"‚ãî","forkv":"‚´ô","fpartint":"‚®ç","frac1":"¬º","frac12":"¬Ω","frac13":"‚Öì","frac14":"¬º","frac15":"‚Öï","frac16":"‚Öô","frac18":"‚Öõ","frac23":"‚Öî","frac25":"‚Öñ","frac3":"¬æ","frac34":"¬æ","frac35":"‚Öó","frac38":"‚Öú","frac45":"‚Öò","frac56":"‚Öö","frac58":"‚Öù","frac78":"‚Öû","frasl":"‚ÅÑ","frown":"‚å¢","fscr":"ùíª","gE":"‚âß","gEl":"‚™å","gacute":"«µ","gamma":"Œ≥","gammad":"œù","gap":"‚™Ü","gbreve":"ƒü","gcirc":"ƒù","gcy":"–≥","gdot":"ƒ°","ge":"‚â•","gel":"‚ãõ","geq":"‚â•","geqq":"‚âß","geqslant":"‚©æ","ges":"‚©æ","gescc":"‚™©","gesdot":"‚™Ä","gesdoto":"‚™Ç","gesdotol":"‚™Ñ","gesl":"‚ãõÔ∏Ä","gesles":"‚™î","gfr":"ùî§","gg":"‚â´","ggg":"‚ãô","gimel":"‚Ñ∑","gjcy":"—ì","gl":"‚â∑","glE":"‚™í","gla":"‚™•","glj":"‚™§","gnE":"‚â©","gnap":"‚™ä","gnapprox":"‚™ä","gne":"‚™à","gneq":"‚™à","gneqq":"‚â©","gnsim":"‚ãß","gopf":"ùïò","grave":"`","gscr":"‚Ñä","gsim":"‚â≥","gsime":"‚™é","gsiml":"‚™ê","g":">","gt":">","gtcc":"‚™ß","gtcir":"‚©∫","gtdot":"‚ãó","gtlPar":"‚¶ï","gtquest":"‚©º","gtrapprox":"‚™Ü","gtrarr":"‚•∏","gtrdot":"‚ãó","gtreqless":"‚ãõ","gtreqqless":"‚™å","gtrless":"‚â∑","gtrsim":"‚â≥","gvertneqq":"‚â©Ô∏Ä","gvnE":"‚â©Ô∏Ä","hArr":"‚áî","hairsp":"‚Ää","half":"¬Ω","hamilt":"‚Ñã","hardcy":"—ä","harr":"‚Üî","harrcir":"‚•à","harrw":"‚Ü≠","hbar":"‚Ñè","hcirc":"ƒ•","hearts":"‚ô•","heartsuit":"‚ô•","hellip":"‚Ä¶","hercon":"‚äπ","hfr":"ùî•","hksearow":"‚§•","hkswarow":"‚§¶","hoarr":"‚áø","homtht":"‚àª","hookleftarrow":"‚Ü©","hookrightarrow":"‚Ü™","hopf":"ùïô","horbar":"‚Äï","hscr":"ùíΩ","hslash":"‚Ñè","hstrok":"ƒß","hybull":"‚ÅÉ","hyphen":"‚Äê","iacut":"√≠","iacute":"√≠","ic":"‚Å£","icir":"√Æ","icirc":"√Æ","icy":"–∏","iecy":"–µ","iexc":"¬°","iexcl":"¬°","iff":"‚áî","ifr":"ùî¶","igrav":"√¨","igrave":"√¨","ii":"‚Öà","iiiint":"‚®å","iiint":"‚à≠","iinfin":"‚ßú","iiota":"‚Ñ©","ijlig":"ƒ≥","imacr":"ƒ´","image":"‚Ñë","imagline":"‚Ñê","imagpart":"‚Ñë","imath":"ƒ±","imof":"‚ä∑","imped":"∆µ","in":"‚àà","incare":"‚ÑÖ","infin":"‚àû","infintie":"‚ßù","inodot":"ƒ±","int":"‚à´","intcal":"‚ä∫","integers":"‚Ñ§","intercal":"‚ä∫","intlarhk":"‚®ó","intprod":"‚®º","iocy":"—ë","iogon":"ƒØ","iopf":"ùïö","iota":"Œπ","iprod":"‚®º","iques":"¬ø","iquest":"¬ø","iscr":"ùíæ","isin":"‚àà","isinE":"‚ãπ","isindot":"‚ãµ","isins":"‚ã¥","isinsv":"‚ã≥","isinv":"‚àà","it":"‚Å¢","itilde":"ƒ©","iukcy":"—ñ","ium":"√Ø","iuml":"√Ø","jcirc":"ƒµ","jcy":"–π","jfr":"ùîß","jmath":"»∑","jopf":"ùïõ","jscr":"ùíø","jsercy":"—ò","jukcy":"—î","kappa":"Œ∫","kappav":"œ∞","kcedil":"ƒ∑","kcy":"–∫","kfr":"ùî®","kgreen":"ƒ∏","khcy":"—Ö","kjcy":"—ú","kopf":"ùïú","kscr":"ùìÄ","lAarr":"‚áö","lArr":"‚áê","lAtail":"‚§õ","lBarr":"‚§é","lE":"‚â¶","lEg":"‚™ã","lHar":"‚•¢","lacute":"ƒ∫","laemptyv":"‚¶¥","lagran":"‚Ñí","lambda":"Œª","lang":"‚ü®","langd":"‚¶ë","langle":"‚ü®","lap":"‚™Ö","laqu":"¬´","laquo":"¬´","larr":"‚Üê","larrb":"‚á§","larrbfs":"‚§ü","larrfs":"‚§ù","larrhk":"‚Ü©","larrlp":"‚Ü´","larrpl":"‚§π","larrsim":"‚•≥","larrtl":"‚Ü¢","lat":"‚™´","latail":"‚§ô","late":"‚™≠","lates":"‚™≠Ô∏Ä","lbarr":"‚§å","lbbrk":"‚ù≤","lbrace":"{","lbrack":"[","lbrke":"‚¶ã","lbrksld":"‚¶è","lbrkslu":"‚¶ç","lcaron":"ƒæ","lcedil":"ƒº","lceil":"‚åà","lcub":"{","lcy":"–ª","ldca":"‚§∂","ldquo":"‚Äú","ldquor":"‚Äû","ldrdhar":"‚•ß","ldrushar":"‚•ã","ldsh":"‚Ü≤","le":"‚â§","leftarrow":"‚Üê","leftarrowtail":"‚Ü¢","leftharpoondown":"‚ÜΩ","leftharpoonup":"‚Üº","leftleftarrows":"‚áá","leftrightarrow":"‚Üî","leftrightarrows":"‚áÜ","leftrightharpoons":"‚áã","leftrightsquigarrow":"‚Ü≠","leftthreetimes":"‚ãã","leg":"‚ãö","leq":"‚â§","leqq":"‚â¶","leqslant":"‚©Ω","les":"‚©Ω","lescc":"‚™®","lesdot":"‚©ø","lesdoto":"‚™Å","lesdotor":"‚™É","lesg":"‚ãöÔ∏Ä","lesges":"‚™ì","lessapprox":"‚™Ö","lessdot":"‚ãñ","lesseqgtr":"‚ãö","lesseqqgtr":"‚™ã","lessgtr":"‚â∂","lesssim":"‚â≤","lfisht":"‚•º","lfloor":"‚åä","lfr":"ùî©","lg":"‚â∂","lgE":"‚™ë","lhard":"‚ÜΩ","lharu":"‚Üº","lharul":"‚•™","lhblk":"‚ñÑ","ljcy":"—ô","ll":"‚â™","llarr":"‚áá","llcorner":"‚åû","llhard":"‚•´","lltri":"‚ó∫","lmidot":"≈Ä","lmoust":"‚é∞","lmoustache":"‚é∞","lnE":"‚â®","lnap":"‚™â","lnapprox":"‚™â","lne":"‚™á","lneq":"‚™á","lneqq":"‚â®","lnsim":"‚ã¶","loang":"‚ü¨","loarr":"‚áΩ","lobrk":"‚ü¶","longleftarrow":"‚üµ","longleftrightarrow":"‚ü∑","longmapsto":"‚üº","longrightarrow":"‚ü∂","looparrowleft":"‚Ü´","looparrowright":"‚Ü¨","lopar":"‚¶Ö","lopf":"ùïù","loplus":"‚®≠","lotimes":"‚®¥","lowast":"‚àó","lowbar":"_","loz":"‚óä","lozenge":"‚óä","lozf":"‚ß´","lpar":"(","lparlt":"‚¶ì","lrarr":"‚áÜ","lrcorner":"‚åü","lrhar":"‚áã","lrhard":"‚•≠","lrm":"‚Äé","lrtri":"‚äø","lsaquo":"‚Äπ","lscr":"ùìÅ","lsh":"‚Ü∞","lsim":"‚â≤","lsime":"‚™ç","lsimg":"‚™è","lsqb":"[","lsquo":"‚Äò","lsquor":"‚Äö","lstrok":"≈Ç","l":"<","lt":"<","ltcc":"‚™¶","ltcir":"‚©π","ltdot":"‚ãñ","lthree":"‚ãã","ltimes":"‚ãâ","ltlarr":"‚•∂","ltquest":"‚©ª","ltrPar":"‚¶ñ","ltri":"‚óÉ","ltrie":"‚ä¥","ltrif":"‚óÇ","lurdshar":"‚•ä","luruhar":"‚•¶","lvertneqq":"‚â®Ô∏Ä","lvnE":"‚â®Ô∏Ä","mDDot":"‚à∫","mac":"¬Ø","macr":"¬Ø","male":"‚ôÇ","malt":"‚ú†","maltese":"‚ú†","map":"‚Ü¶","mapsto":"‚Ü¶","mapstodown":"‚Üß","mapstoleft":"‚Ü§","mapstoup":"‚Ü•","marker":"‚ñÆ","mcomma":"‚®©","mcy":"–º","mdash":"‚Äî","measuredangle":"‚à°","mfr":"ùî™","mho":"‚Ñß","micr":"¬µ","micro":"¬µ","mid":"‚à£","midast":"*","midcir":"‚´∞","middo":"¬∑","middot":"¬∑","minus":"‚àí","minusb":"‚äü","minusd":"‚à∏","minusdu":"‚®™","mlcp":"‚´õ","mldr":"‚Ä¶","mnplus":"‚àì","models":"‚äß","mopf":"ùïû","mp":"‚àì","mscr":"ùìÇ","mstpos":"‚àæ","mu":"Œº","multimap":"‚ä∏","mumap":"‚ä∏","nGg":"‚ãôÃ∏","nGt":"‚â´‚Éí","nGtv":"‚â´Ã∏","nLeftarrow":"‚áç","nLeftrightarrow":"‚áé","nLl":"‚ãòÃ∏","nLt":"‚â™‚Éí","nLtv":"‚â™Ã∏","nRightarrow":"‚áè","nVDash":"‚äØ","nVdash":"‚äÆ","nabla":"‚àá","nacute":"≈Ñ","nang":"‚à†‚Éí","nap":"‚ââ","napE":"‚©∞Ã∏","napid":"‚âãÃ∏","napos":"≈â","napprox":"‚ââ","natur":"‚ôÆ","natural":"‚ôÆ","naturals":"‚Ñï","nbs":"¬†","nbsp":"¬†","nbump":"‚âéÃ∏","nbumpe":"‚âèÃ∏","ncap":"‚©É","ncaron":"≈à","ncedil":"≈Ü","ncong":"‚âá","ncongdot":"‚©≠Ã∏","ncup":"‚©Ç","ncy":"–Ω","ndash":"‚Äì","ne":"‚â†","neArr":"‚áó","nearhk":"‚§§","nearr":"‚Üó","nearrow":"‚Üó","nedot":"‚âêÃ∏","nequiv":"‚â¢","nesear":"‚§®","nesim":"‚âÇÃ∏","nexist":"‚àÑ","nexists":"‚àÑ","nfr":"ùî´","ngE":"‚âßÃ∏","nge":"‚â±","ngeq":"‚â±","ngeqq":"‚âßÃ∏","ngeqslant":"‚©æÃ∏","nges":"‚©æÃ∏","ngsim":"‚âµ","ngt":"‚âØ","ngtr":"‚âØ","nhArr":"‚áé","nharr":"‚ÜÆ","nhpar":"‚´≤","ni":"‚àã","nis":"‚ãº","nisd":"‚ã∫","niv":"‚àã","njcy":"—ö","nlArr":"‚áç","nlE":"‚â¶Ã∏","nlarr":"‚Üö","nldr":"‚Ä•","nle":"‚â∞","nleftarrow":"‚Üö","nleftrightarrow":"‚ÜÆ","nleq":"‚â∞","nleqq":"‚â¶Ã∏","nleqslant":"‚©ΩÃ∏","nles":"‚©ΩÃ∏","nless":"‚âÆ","nlsim":"‚â¥","nlt":"‚âÆ","nltri":"‚ã™","nltrie":"‚ã¨","nmid":"‚à§","nopf":"ùïü","no":"¬¨","not":"¬¨","notin":"‚àâ","notinE":"‚ãπÃ∏","notindot":"‚ãµÃ∏","notinva":"‚àâ","notinvb":"‚ã∑","notinvc":"‚ã∂","notni":"‚àå","notniva":"‚àå","notnivb":"‚ãæ","notnivc":"‚ãΩ","npar":"‚à¶","nparallel":"‚à¶","nparsl":"‚´Ω‚É•","npart":"‚àÇÃ∏","npolint":"‚®î","npr":"‚äÄ","nprcue":"‚ã†","npre":"‚™ØÃ∏","nprec":"‚äÄ","npreceq":"‚™ØÃ∏","nrArr":"‚áè","nrarr":"‚Üõ","nrarrc":"‚§≥Ã∏","nrarrw":"‚ÜùÃ∏","nrightarrow":"‚Üõ","nrtri":"‚ã´","nrtrie":"‚ã≠","nsc":"‚äÅ","nsccue":"‚ã°","nsce":"‚™∞Ã∏","nscr":"ùìÉ","nshortmid":"‚à§","nshortparallel":"‚à¶","nsim":"‚âÅ","nsime":"‚âÑ","nsimeq":"‚âÑ","nsmid":"‚à§","nspar":"‚à¶","nsqsube":"‚ã¢","nsqsupe":"‚ã£","nsub":"‚äÑ","nsubE":"‚´ÖÃ∏","nsube":"‚äà","nsubset":"‚äÇ‚Éí","nsubseteq":"‚äà","nsubseteqq":"‚´ÖÃ∏","nsucc":"‚äÅ","nsucceq":"‚™∞Ã∏","nsup":"‚äÖ","nsupE":"‚´ÜÃ∏","nsupe":"‚äâ","nsupset":"‚äÉ‚Éí","nsupseteq":"‚äâ","nsupseteqq":"‚´ÜÃ∏","ntgl":"‚âπ","ntild":"√±","ntilde":"√±","ntlg":"‚â∏","ntriangleleft":"‚ã™","ntrianglelefteq":"‚ã¨","ntriangleright":"‚ã´","ntrianglerighteq":"‚ã≠","nu":"ŒΩ","num":"#","numero":"‚Ññ","numsp":"‚Äá","nvDash":"‚ä≠","nvHarr":"‚§Ñ","nvap":"‚âç‚Éí","nvdash":"‚ä¨","nvge":"‚â•‚Éí","nvgt":">‚Éí","nvinfin":"‚ßû","nvlArr":"‚§Ç","nvle":"‚â§‚Éí","nvlt":"<‚Éí","nvltrie":"‚ä¥‚Éí","nvrArr":"‚§É","nvrtrie":"‚äµ‚Éí","nvsim":"‚àº‚Éí","nwArr":"‚áñ","nwarhk":"‚§£","nwarr":"‚Üñ","nwarrow":"‚Üñ","nwnear":"‚§ß","oS":"‚ìà","oacut":"√≥","oacute":"√≥","oast":"‚äõ","ocir":"√¥","ocirc":"√¥","ocy":"–æ","odash":"‚äù","odblac":"≈ë","odiv":"‚®∏","odot":"‚äô","odsold":"‚¶º","oelig":"≈ì","ofcir":"‚¶ø","ofr":"ùî¨","ogon":"Àõ","ograv":"√≤","ograve":"√≤","ogt":"‚ßÅ","ohbar":"‚¶µ","ohm":"Œ©","oint":"‚àÆ","olarr":"‚Ü∫","olcir":"‚¶æ","olcross":"‚¶ª","oline":"‚Äæ","olt":"‚ßÄ","omacr":"≈ç","omega":"œâ","omicron":"Œø","omid":"‚¶∂","ominus":"‚äñ","oopf":"ùï†","opar":"‚¶∑","operp":"‚¶π","oplus":"‚äï","or":"‚à®","orarr":"‚Üª","ord":"¬∫","order":"‚Ñ¥","orderof":"‚Ñ¥","ordf":"¬™","ordm":"¬∫","origof":"‚ä∂","oror":"‚©ñ","orslope":"‚©ó","orv":"‚©õ","oscr":"‚Ñ¥","oslas":"√∏","oslash":"√∏","osol":"‚äò","otild":"√µ","otilde":"√µ","otimes":"‚äó","otimesas":"‚®∂","oum":"√∂","ouml":"√∂","ovbar":"‚åΩ","par":"¬∂","para":"¬∂","parallel":"‚à•","parsim":"‚´≥","parsl":"‚´Ω","part":"‚àÇ","pcy":"–ø","percnt":"%","period":".","permil":"‚Ä∞","perp":"‚ä•","pertenk":"‚Ä±","pfr":"ùî≠","phi":"œÜ","phiv":"œï","phmmat":"‚Ñ≥","phone":"‚òé","pi":"œÄ","pitchfork":"‚ãî","piv":"œñ","planck":"‚Ñè","planckh":"‚Ñé","plankv":"‚Ñè","plus":"+","plusacir":"‚®£","plusb":"‚äû","pluscir":"‚®¢","plusdo":"‚àî","plusdu":"‚®•","pluse":"‚©≤","plusm":"¬±","plusmn":"¬±","plussim":"‚®¶","plustwo":"‚®ß","pm":"¬±","pointint":"‚®ï","popf":"ùï°","poun":"¬£","pound":"¬£","pr":"‚â∫","prE":"‚™≥","prap":"‚™∑","prcue":"‚âº","pre":"‚™Ø","prec":"‚â∫","precapprox":"‚™∑","preccurlyeq":"‚âº","preceq":"‚™Ø","precnapprox":"‚™π","precneqq":"‚™µ","precnsim":"‚ã®","precsim":"‚âæ","prime":"‚Ä≤","primes":"‚Ñô","prnE":"‚™µ","prnap":"‚™π","prnsim":"‚ã®","prod":"‚àè","profalar":"‚åÆ","profline":"‚åí","profsurf":"‚åì","prop":"‚àù","propto":"‚àù","prsim":"‚âæ","prurel":"‚ä∞","pscr":"ùìÖ","psi":"œà","puncsp":"‚Äà","qfr":"ùîÆ","qint":"‚®å","qopf":"ùï¢","qprime":"‚Åó","qscr":"ùìÜ","quaternions":"‚Ñç","quatint":"‚®ñ","quest":"?","questeq":"‚âü","quo":"\\"","quot":"\\"","rAarr":"‚áõ","rArr":"‚áí","rAtail":"‚§ú","rBarr":"‚§è","rHar":"‚•§","race":"‚àΩÃ±","racute":"≈ï","radic":"‚àö","raemptyv":"‚¶≥","rang":"‚ü©","rangd":"‚¶í","range":"‚¶•","rangle":"‚ü©","raqu":"¬ª","raquo":"¬ª","rarr":"‚Üí","rarrap":"‚•µ","rarrb":"‚á•","rarrbfs":"‚§†","rarrc":"‚§≥","rarrfs":"‚§û","rarrhk":"‚Ü™","rarrlp":"‚Ü¨","rarrpl":"‚•Ö","rarrsim":"‚•¥","rarrtl":"‚Ü£","rarrw":"‚Üù","ratail":"‚§ö","ratio":"‚à∂","rationals":"‚Ñö","rbarr":"‚§ç","rbbrk":"‚ù≥","rbrace":"}","rbrack":"]","rbrke":"‚¶å","rbrksld":"‚¶é","rbrkslu":"‚¶ê","rcaron":"≈ô","rcedil":"≈ó","rceil":"‚åâ","rcub":"}","rcy":"—Ä","rdca":"‚§∑","rdldhar":"‚•©","rdquo":"‚Äù","rdquor":"‚Äù","rdsh":"‚Ü≥","real":"‚Ñú","realine":"‚Ñõ","realpart":"‚Ñú","reals":"‚Ñù","rect":"‚ñ≠","re":"¬Æ","reg":"¬Æ","rfisht":"‚•Ω","rfloor":"‚åã","rfr":"ùîØ","rhard":"‚áÅ","rharu":"‚áÄ","rharul":"‚•¨","rho":"œÅ","rhov":"œ±","rightarrow":"‚Üí","rightarrowtail":"‚Ü£","rightharpoondown":"‚áÅ","rightharpoonup":"‚áÄ","rightleftarrows":"‚áÑ","rightleftharpoons":"‚áå","rightrightarrows":"‚áâ","rightsquigarrow":"‚Üù","rightthreetimes":"‚ãå","ring":"Àö","risingdotseq":"‚âì","rlarr":"‚áÑ","rlhar":"‚áå","rlm":"‚Äè","rmoust":"‚é±","rmoustache":"‚é±","rnmid":"‚´Æ","roang":"‚ü≠","roarr":"‚áæ","robrk":"‚üß","ropar":"‚¶Ü","ropf":"ùï£","roplus":"‚®Æ","rotimes":"‚®µ","rpar":")","rpargt":"‚¶î","rppolint":"‚®í","rrarr":"‚áâ","rsaquo":"‚Ä∫","rscr":"ùìá","rsh":"‚Ü±","rsqb":"]","rsquo":"‚Äô","rsquor":"‚Äô","rthree":"‚ãå","rtimes":"‚ãä","rtri":"‚ñπ","rtrie":"‚äµ","rtrif":"‚ñ∏","rtriltri":"‚ßé","ruluhar":"‚•®","rx":"‚Ñû","sacute":"≈õ","sbquo":"‚Äö","sc":"‚âª","scE":"‚™¥","scap":"‚™∏","scaron":"≈°","sccue":"‚âΩ","sce":"‚™∞","scedil":"≈ü","scirc":"≈ù","scnE":"‚™∂","scnap":"‚™∫","scnsim":"‚ã©","scpolint":"‚®ì","scsim":"‚âø","scy":"—Å","sdot":"‚ãÖ","sdotb":"‚ä°","sdote":"‚©¶","seArr":"‚áò","searhk":"‚§•","searr":"‚Üò","searrow":"‚Üò","sec":"¬ß","sect":"¬ß","semi":";","seswar":"‚§©","setminus":"‚àñ","setmn":"‚àñ","sext":"‚ú∂","sfr":"ùî∞","sfrown":"‚å¢","sharp":"‚ôØ","shchcy":"—â","shcy":"—à","shortmid":"‚à£","shortparallel":"‚à•","sh":"¬≠","shy":"¬≠","sigma":"œÉ","sigmaf":"œÇ","sigmav":"œÇ","sim":"‚àº","simdot":"‚©™","sime":"‚âÉ","simeq":"‚âÉ","simg":"‚™û","simgE":"‚™†","siml":"‚™ù","simlE":"‚™ü","simne":"‚âÜ","simplus":"‚®§","simrarr":"‚•≤","slarr":"‚Üê","smallsetminus":"‚àñ","smashp":"‚®≥","smeparsl":"‚ß§","smid":"‚à£","smile":"‚å£","smt":"‚™™","smte":"‚™¨","smtes":"‚™¨Ô∏Ä","softcy":"—å","sol":"/","solb":"‚ßÑ","solbar":"‚åø","sopf":"ùï§","spades":"‚ô†","spadesuit":"‚ô†","spar":"‚à•","sqcap":"‚äì","sqcaps":"‚äìÔ∏Ä","sqcup":"‚äî","sqcups":"‚äîÔ∏Ä","sqsub":"‚äè","sqsube":"‚äë","sqsubset":"‚äè","sqsubseteq":"‚äë","sqsup":"‚äê","sqsupe":"‚äí","sqsupset":"‚äê","sqsupseteq":"‚äí","squ":"‚ñ°","square":"‚ñ°","squarf":"‚ñ™","squf":"‚ñ™","srarr":"‚Üí","sscr":"ùìà","ssetmn":"‚àñ","ssmile":"‚å£","sstarf":"‚ãÜ","star":"‚òÜ","starf":"‚òÖ","straightepsilon":"œµ","straightphi":"œï","strns":"¬Ø","sub":"‚äÇ","subE":"‚´Ö","subdot":"‚™Ω","sube":"‚äÜ","subedot":"‚´É","submult":"‚´Å","subnE":"‚´ã","subne":"‚ää","subplus":"‚™ø","subrarr":"‚•π","subset":"‚äÇ","subseteq":"‚äÜ","subseteqq":"‚´Ö","subsetneq":"‚ää","subsetneqq":"‚´ã","subsim":"‚´á","subsub":"‚´ï","subsup":"‚´ì","succ":"‚âª","succapprox":"‚™∏","succcurlyeq":"‚âΩ","succeq":"‚™∞","succnapprox":"‚™∫","succneqq":"‚™∂","succnsim":"‚ã©","succsim":"‚âø","sum":"‚àë","sung":"‚ô™","sup":"‚äÉ","sup1":"¬π","sup2":"¬≤","sup3":"¬≥","supE":"‚´Ü","supdot":"‚™æ","supdsub":"‚´ò","supe":"‚äá","supedot":"‚´Ñ","suphsol":"‚üâ","suphsub":"‚´ó","suplarr":"‚•ª","supmult":"‚´Ç","supnE":"‚´å","supne":"‚äã","supplus":"‚´Ä","supset":"‚äÉ","supseteq":"‚äá","supseteqq":"‚´Ü","supsetneq":"‚äã","supsetneqq":"‚´å","supsim":"‚´à","supsub":"‚´î","supsup":"‚´ñ","swArr":"‚áô","swarhk":"‚§¶","swarr":"‚Üô","swarrow":"‚Üô","swnwar":"‚§™","szli":"√ü","szlig":"√ü","target":"‚åñ","tau":"œÑ","tbrk":"‚é¥","tcaron":"≈•","tcedil":"≈£","tcy":"—Ç","tdot":"‚Éõ","telrec":"‚åï","tfr":"ùî±","there4":"‚à¥","therefore":"‚à¥","theta":"Œ∏","thetasym":"œë","thetav":"œë","thickapprox":"‚âà","thicksim":"‚àº","thinsp":"‚Äâ","thkap":"‚âà","thksim":"‚àº","thor":"√æ","thorn":"√æ","tilde":"Àú","time":"√ó","times":"√ó","timesb":"‚ä†","timesbar":"‚®±","timesd":"‚®∞","tint":"‚à≠","toea":"‚§®","top":"‚ä§","topbot":"‚å∂","topcir":"‚´±","topf":"ùï•","topfork":"‚´ö","tosa":"‚§©","tprime":"‚Ä¥","trade":"‚Ñ¢","triangle":"‚ñµ","triangledown":"‚ñø","triangleleft":"‚óÉ","trianglelefteq":"‚ä¥","triangleq":"‚âú","triangleright":"‚ñπ","trianglerighteq":"‚äµ","tridot":"‚ó¨","trie":"‚âú","triminus":"‚®∫","triplus":"‚®π","trisb":"‚ßç","tritime":"‚®ª","trpezium":"‚è¢","tscr":"ùìâ","tscy":"—Ü","tshcy":"—õ","tstrok":"≈ß","twixt":"‚â¨","twoheadleftarrow":"‚Üû","twoheadrightarrow":"‚Ü†","uArr":"‚áë","uHar":"‚•£","uacut":"√∫","uacute":"√∫","uarr":"‚Üë","ubrcy":"—û","ubreve":"≈≠","ucir":"√ª","ucirc":"√ª","ucy":"—É","udarr":"‚áÖ","udblac":"≈±","udhar":"‚•Æ","ufisht":"‚•æ","ufr":"ùî≤","ugrav":"√π","ugrave":"√π","uharl":"‚Üø","uharr":"‚Üæ","uhblk":"‚ñÄ","ulcorn":"‚åú","ulcorner":"‚åú","ulcrop":"‚åè","ultri":"‚ó∏","umacr":"≈´","um":"¬®","uml":"¬®","uogon":"≈≥","uopf":"ùï¶","uparrow":"‚Üë","updownarrow":"‚Üï","upharpoonleft":"‚Üø","upharpoonright":"‚Üæ","uplus":"‚äé","upsi":"œÖ","upsih":"œí","upsilon":"œÖ","upuparrows":"‚áà","urcorn":"‚åù","urcorner":"‚åù","urcrop":"‚åé","uring":"≈Ø","urtri":"‚óπ","uscr":"ùìä","utdot":"‚ã∞","utilde":"≈©","utri":"‚ñµ","utrif":"‚ñ¥","uuarr":"‚áà","uum":"√º","uuml":"√º","uwangle":"‚¶ß","vArr":"‚áï","vBar":"‚´®","vBarv":"‚´©","vDash":"‚ä®","vangrt":"‚¶ú","varepsilon":"œµ","varkappa":"œ∞","varnothing":"‚àÖ","varphi":"œï","varpi":"œñ","varpropto":"‚àù","varr":"‚Üï","varrho":"œ±","varsigma":"œÇ","varsubsetneq":"‚ääÔ∏Ä","varsubsetneqq":"‚´ãÔ∏Ä","varsupsetneq":"‚äãÔ∏Ä","varsupsetneqq":"‚´åÔ∏Ä","vartheta":"œë","vartriangleleft":"‚ä≤","vartriangleright":"‚ä≥","vcy":"–≤","vdash":"‚ä¢","vee":"‚à®","veebar":"‚äª","veeeq":"‚âö","vellip":"‚ãÆ","verbar":"|","vert":"|","vfr":"ùî≥","vltri":"‚ä≤","vnsub":"‚äÇ‚Éí","vnsup":"‚äÉ‚Éí","vopf":"ùïß","vprop":"‚àù","vrtri":"‚ä≥","vscr":"ùìã","vsubnE":"‚´ãÔ∏Ä","vsubne":"‚ääÔ∏Ä","vsupnE":"‚´åÔ∏Ä","vsupne":"‚äãÔ∏Ä","vzigzag":"‚¶ö","wcirc":"≈µ","wedbar":"‚©ü","wedge":"‚àß","wedgeq":"‚âô","weierp":"‚Ñò","wfr":"ùî¥","wopf":"ùï®","wp":"‚Ñò","wr":"‚âÄ","wreath":"‚âÄ","wscr":"ùìå","xcap":"‚ãÇ","xcirc":"‚óØ","xcup":"‚ãÉ","xdtri":"‚ñΩ","xfr":"ùîµ","xhArr":"‚ü∫","xharr":"‚ü∑","xi":"Œæ","xlArr":"‚ü∏","xlarr":"‚üµ","xmap":"‚üº","xnis":"‚ãª","xodot":"‚®Ä","xopf":"ùï©","xoplus":"‚®Å","xotime":"‚®Ç","xrArr":"‚üπ","xrarr":"‚ü∂","xscr":"ùìç","xsqcup":"‚®Ü","xuplus":"‚®Ñ","xutri":"‚ñ≥","xvee":"‚ãÅ","xwedge":"‚ãÄ","yacut":"√Ω","yacute":"√Ω","yacy":"—è","ycirc":"≈∑","ycy":"—ã","ye":"¬•","yen":"¬•","yfr":"ùî∂","yicy":"—ó","yopf":"ùï™","yscr":"ùìé","yucy":"—é","yum":"√ø","yuml":"√ø","zacute":"≈∫","zcaron":"≈æ","zcy":"–∑","zdot":"≈º","zeetrf":"‚Ñ®","zeta":"Œ∂","zfr":"ùî∑","zhcy":"–∂","zigrarr":"‚áù","zopf":"ùï´","zscr":"ùìè","zwj":"‚Äç","zwnj":"‚Äå"}');
¬© ","COPY":"¬©","copysr":"‚Ñó","CounterClockwiseContourIntegral":"‚à≥","crarr":"‚Üµ","cross":"‚úó","Cross":"‚®Ø","Cscr":"ùíû","cscr":"ùí∏","csub":"‚´è","csube":"‚´ë","csup":"‚´ê","csupe":"‚´í","ctdot":"‚ãØ","cudarrl":"‚§∏","cudarrr":"‚§µ","cuepr":"‚ãû","cuesc":"‚ãü","cularr":"‚Ü∂","cularrp":"‚§Ω","cupbrcap":"‚©à","cupcap":"‚©Ü","CupCap":"‚âç","cup":"‚à™","Cup":"‚ãì","cupcup":"‚©ä","cupdot":"‚äç","cupor":"‚©Ö","cups":"‚à™Ô∏Ä","curarr":"‚Ü∑","curarrm":"‚§º","curlyeqprec":"‚ãû","curlyeqsucc":"‚ãü","curlyvee":"‚ãé","curlywedge":"‚ãè","curren":"¬§","curvearrowleft":"‚Ü∂","curvearrowright":"‚Ü∑","cuvee":"‚ãé","cuwed":"‚ãè","cwconint":"‚à≤","cwint":"‚à±","cylcty":"‚å≠","dagger":"‚Ä†","Dagger":"‚Ä°","daleth":"‚Ñ∏","darr":"‚Üì","Darr":"‚Ü°","dArr":"‚áì","dash":"‚Äê","Dashv":"‚´§","dashv":"‚ä£","dbkarow":"‚§è","dblac":"Àù","Dcaron":"ƒé","dcaron":"ƒè","Dcy":"–î","dcy":"–¥","ddagger":"‚Ä°","ddarr":"‚áä","DD":"‚ÖÖ","dd":"‚ÖÜ","DDotrahd":"‚§ë","ddotseq":"‚©∑","deg":"¬∞","Del":"‚àá","Delta":"Œî","delta":"Œ¥","demptyv":"‚¶±","dfisht":"‚•ø","Dfr":"ùîá","dfr":"ùî°","dHar":"‚••","dharl":"‚áÉ","dharr":"‚áÇ","DiacriticalAcute":"¬¥","DiacriticalDot":"Àô","DiacriticalDoubleAcute":"Àù","DiacriticalGrave":"`","DiacriticalTilde":"Àú","diam":"‚ãÑ","diamond":"‚ãÑ","Diamond":"‚ãÑ","diamondsuit":"‚ô¶","diams":"‚ô¶","die":"¬®","DifferentialD":"‚ÖÜ","digamma":"œù","disin":"‚ã≤","div":"√∑","divide":"√∑","divideontimes":"‚ãá","divonx":"‚ãá","DJcy":"–Ç","djcy":"—í","dlcorn":"‚åû","dlcrop":"‚åç","dollar":"$","Dopf":"ùîª","dopf":"ùïï","Dot":"¬®","dot":"Àô","DotDot":"‚Éú","doteq":"‚âê","doteqdot":"‚âë","DotEqual":"‚âê","dotminus":"‚à∏","dotplus":"‚àî","dotsquare":"‚ä°","doublebarwedge":"‚åÜ","DoubleContourIntegral":"‚àØ","DoubleDot":"¬®","DoubleDownArrow":"‚áì","DoubleLeftArrow":"‚áê","DoubleLeftRightArrow":"‚áî","DoubleLeftTee":"‚´§","DoubleLongLeftArrow":"‚ü∏","DoubleLongLeftRightArrow":"‚ü∫","DoubleLongRightArrow":"‚üπ","DoubleRightArrow":"‚áí","DoubleRightTee":"‚ä®","DoubleUpArrow":"‚áë","DoubleUpDownArrow":"‚áï","DoubleVerticalBar":"‚à•","DownArrowBar":"‚§ì","downarrow":"‚Üì","DownArrow":"‚Üì","Downarrow":"‚áì","DownArrowUpArrow":"‚áµ","DownBreve":"Ãë","downdownarrows":"‚áä","downharpoonleft":"‚áÉ","downharpoonright":"‚áÇ","DownLeftRightVector":"‚•ê","DownLeftTeeVector":"‚•û","DownLeftVectorBar":"‚•ñ","DownLeftVector":"‚ÜΩ","DownRightTeeVector":"‚•ü","DownRightVectorBar":"‚•ó","DownRightVector":"‚áÅ","DownTeeArrow":"‚Üß","DownTee":"‚ä§","drbkarow":"‚§ê","drcorn":"‚åü","drcrop":"‚åå","Dscr":"ùíü","dscr":"ùíπ","DScy":"–Ö","dscy":"—ï","dsol":"‚ß∂","Dstrok":"ƒê","dstrok":"ƒë","dtdot":"‚ã±","dtri":"‚ñø","dtrif":"‚ñæ","duarr":"‚áµ","duhar":"‚•Ø","dwangle":"‚¶¶","DZcy":"–è","dzcy":"—ü","dzigrarr":"‚üø","Eacute":"√â","eacute":"√©","easter":"‚©Æ","Ecaron":"ƒö","ecaron":"ƒõ","Ecirc":"√ä","ecirc":"√™","ecir":"‚âñ","ecolon":"‚âï","Ecy":"–≠","ecy":"—ç","eDDot":"‚©∑","Edot":"ƒñ","edot":"ƒó","eDot":"‚âë","ee":"‚Öá","efDot":"‚âí","Efr":"ùîà","efr":"ùî¢","eg":"‚™ö","Egrave":"√à","egrave":"√®","egs":"‚™ñ","egsdot":"‚™ò","el":"‚™ô","Element":"‚àà","elinters":"‚èß","ell":"‚Ñì","els":"‚™ï","elsdot":"‚™ó","Emacr":"ƒí","emacr":"ƒì","empty":"‚àÖ","emptyset":"‚àÖ","EmptySmallSquare":"‚óª","emptyv":"‚àÖ","EmptyVerySmallSquare":"‚ñ´","emsp13":"‚ÄÑ","emsp14":"‚ÄÖ","emsp":"‚ÄÉ","ENG":"≈ä","eng":"≈ã","ensp":"‚ÄÇ","Eogon":"ƒò","eogon":"ƒô","Eopf":"ùîº","eopf":"ùïñ","epar":"‚ãï","eparsl":"‚ß£","eplus":"‚©±","epsi":"Œµ","Epsilon":"Œï","epsilon":"Œµ","epsiv":"œµ","eqcirc":"‚âñ","eqcolon":"‚âï","eqsim":"‚âÇ","eqslantgtr":"‚™ñ","eqslantless":"‚™ï","Equal":"‚©µ","equals":"=","EqualTilde":"‚âÇ","equest":"‚âü","Equilibrium":"‚áå","equiv":"‚â°","equivDD":"‚©∏","eqvparsl":"‚ß•","erarr":"‚•±","erDot":"‚âì","escr":"‚ÑØ","Escr":"‚Ñ∞","esdot":"‚âê","Esim":"‚©≥","esim":"‚âÇ","Eta":"Œó","eta":"Œ∑","ETH":"√ê","eth":"√∞","Euml":"√ã","euml":"√´","euro":"‚Ç¨","excl":"!","exist":"‚àÉ","Exists":"‚àÉ","expectation":"‚Ñ∞","exponentiale":"‚Öá","ExponentialE":"‚Öá","fallingdotseq":"‚âí","Fcy":"–§","fcy":"—Ñ","female":"‚ôÄ","ffilig":"Ô¨É","fflig":"Ô¨Ä","ffllig":"Ô¨Ñ","Ffr":"ùîâ","ffr":"ùî£","filig":"Ô¨Å","FilledSmallSquare":"‚óº","FilledVerySmallSquare":"‚ñ™","fjlig":"fj","flat":"‚ô≠","fllig":"Ô¨Ç","fltns":"‚ñ±","fnof":"∆í","Fopf":"ùîΩ","fopf":"ùïó","forall":"‚àÄ","ForAll":"‚àÄ","fork":"‚ãî","forkv":"‚´ô","Fouriertrf":"‚Ñ±","fpartint":"‚®ç","frac12":"¬Ω","frac13":"‚Öì","frac14":"¬º","frac15":"‚Öï","frac16":"‚Öô","frac18":"‚Öõ","frac23":"‚Öî","frac25":"‚Öñ","frac34":"¬æ","frac35":"‚Öó","frac38":"‚Öú","frac45":"‚Öò","frac56":"‚Öö","frac58":"‚Öù","frac78":"‚Öû","frasl":"‚ÅÑ","frown":"‚å¢","fscr":"ùíª","Fscr":"‚Ñ±","gacute":"«µ","Gamma":"Œì","gamma":"Œ≥","Gammad":"œú","gammad":"œù","gap":"‚™Ü","Gbreve":"ƒû","gbreve":"ƒü","Gcedil":"ƒ¢","Gcirc":"ƒú","gcirc":"ƒù","Gcy":"–ì","gcy":"–≥","Gdot":"ƒ†","gdot":"ƒ°","ge":"‚â•","gE":"‚âß","gEl":"‚™å","gel":"‚ãõ","geq":"‚â•","geqq":"‚âß","geqslant":"‚©æ","gescc":"‚™©","ges":"‚©æ","gesdot":"‚™Ä","gesdoto":"‚™Ç","gesdotol":"‚™Ñ","gesl":"‚ãõÔ∏Ä","gesles":"‚™î","Gfr":"ùîä","gfr":"ùî§","gg":"‚â´","Gg":"‚ãô","ggg":"‚ãô","gimel":"‚Ñ∑","GJcy":"–É","gjcy":"—ì","gla":"‚™•","gl":"‚â∑","glE":"‚™í","glj":"‚™§","gnap":"‚™ä","gnapprox":"‚™ä","gne":"‚™à","gnE":"‚â©","gneq":"‚™à","gneqq":"‚â©","gnsim":"‚ãß","Gopf":"ùîæ","gopf":"ùïò","grave":"`","GreaterEqual":"‚â•","GreaterEqualLess":"‚ãõ","GreaterFullEqual":"‚âß","GreaterGreater":"‚™¢","GreaterLess":"‚â∑","GreaterSlantEqual":"‚©æ","GreaterTilde":"‚â≥","Gscr":"ùí¢","gscr":"‚Ñä","gsim":"‚â≥","gsime":"‚™é","gsiml":"‚™ê","gtcc":"‚™ß","gtcir":"‚©∫","gt":">","GT":">","Gt":"‚â´","gtdot":"‚ãó","gtlPar":"‚¶ï","gtquest":"‚©º","gtrapprox":"‚™Ü","gtrarr":"‚•∏","gtrdot":"‚ãó","gtreqless":"‚ãõ","gtreqqless":"‚™å","gtrless":"‚â∑","gtrsim":"‚â≥","gvertneqq":"‚â©Ô∏Ä","gvnE":"‚â©Ô∏Ä","Hacek":"Àá","hairsp":"‚Ää","half":"¬Ω","hamilt":"‚Ñã","HARDcy":"–™","hardcy":"—ä","harrcir":"‚•à","harr":"‚Üî","hArr":"‚áî","harrw":"‚Ü≠","Hat":"^","hbar":"‚Ñè","Hcirc":"ƒ§","hcirc":"ƒ•","hearts":"‚ô•","heartsuit":"‚ô•","hellip":"‚Ä¶","hercon":"‚äπ","hfr":"ùî•","Hfr":"‚Ñå","HilbertSpace":"‚Ñã","hksearow":"‚§•","hkswarow":"‚§¶","hoarr":"‚áø","homtht":"‚àª","hookleftarrow":"‚Ü©","hookrightarrow":"‚Ü™","hopf":"ùïô","Hopf":"‚Ñç","horbar":"‚Äï","HorizontalLine":"‚îÄ","hscr":"ùíΩ","Hscr":"‚Ñã","hslash":"‚Ñè","Hstrok":"ƒ¶","hstrok":"ƒß","HumpDownHump":"‚âé","HumpEqual":"‚âè","hybull":"‚ÅÉ","hyphen":"‚Äê","Iacute":"√ç","iacute":"√≠","ic":"‚Å£","Icirc":"√é","icirc":"√Æ","Icy":"–ò","icy":"–∏","Idot":"ƒ∞","IEcy":"–ï","iecy":"–µ","iexcl":"¬°","iff":"‚áî","ifr":"ùî¶","Ifr":"‚Ñë","Igrave":"√å","igrave":"√¨","ii":"‚Öà","iiiint":"‚®å","iiint":"‚à≠","iinfin":"‚ßú","iiota":"‚Ñ©","IJlig":"ƒ≤","ijlig":"ƒ≥","Imacr":"ƒ™","imacr":"ƒ´","image":"‚Ñë","ImaginaryI":"‚Öà","imagline":"‚Ñê","imagpart":"‚Ñë","imath":"ƒ±","Im":"‚Ñë","imof":"‚ä∑","imped":"∆µ","Implies":"‚áí","incare":"‚ÑÖ","in":"‚àà","infin":"‚àû","infintie":"‚ßù","inodot":"ƒ±","intcal":"‚ä∫","int":"‚à´","Int":"‚à¨","integers":"‚Ñ§","Integral":"‚à´","intercal":"‚ä∫","Intersection":"‚ãÇ","intlarhk":"‚®ó","intprod":"‚®º","InvisibleComma":"‚Å£","InvisibleTimes":"‚Å¢","IOcy":"–Å","iocy":"—ë","Iogon":"ƒÆ","iogon":"ƒØ","Iopf":"ùïÄ","iopf":"ùïö","Iota":"Œô","iota":"Œπ","iprod":"‚®º","iquest":"¬ø","iscr":"ùíæ","Iscr":"‚Ñê","isin":"‚àà","isindot":"‚ãµ","isinE":"‚ãπ","isins":"‚ã¥","isinsv":"‚ã≥","isinv":"‚àà","it":"‚Å¢","Itilde":"ƒ®","itilde":"ƒ©","Iukcy":"–Ü","iukcy":"—ñ","Iuml":"√è","iuml":"√Ø","Jcirc":"ƒ¥","jcirc":"ƒµ","Jcy":"–ô","jcy":"–π","Jfr":"ùîç","jfr":"ùîß","jmath":"»∑","Jopf":"ùïÅ","jopf":"ùïõ","Jscr":"ùí•","jscr":"ùíø","Jsercy":"–à","jsercy":"—ò","Jukcy":"–Ñ","jukcy":"—î","Kappa":"Œö","kappa":"Œ∫","kappav":"œ∞","Kcedil":"ƒ∂","kcedil":"ƒ∑","Kcy":"–ö","kcy":"–∫","Kfr":"ùîé","kfr":"ùî®","kgreen":"ƒ∏","KHcy":"–•","khcy":"—Ö","KJcy":"–å","kjcy":"—ú","Kopf":"ùïÇ","kopf":"ùïú","Kscr":"ùí¶","kscr":"ùìÄ","lAarr":"‚áö","Lacute":"ƒπ","lacute":"ƒ∫","laemptyv":"‚¶¥","lagran":"‚Ñí","Lambda":"Œõ","lambda":"Œª","lang":"‚ü®","Lang":"‚ü™","langd":"‚¶ë","langle":"‚ü®","lap":"‚™Ö","Laplacetrf":"‚Ñí","laquo":"¬´","larrb":"‚á§","larrbfs":"‚§ü","larr":"‚Üê","Larr":"‚Üû","lArr":"‚áê","larrfs":"‚§ù","larrhk":"‚Ü©","larrlp":"‚Ü´","larrpl":"‚§π","larrsim":"‚•≥","larrtl":"‚Ü¢","latail":"‚§ô","lAtail":"‚§õ","lat":"‚™´","late":"‚™≠","lates":"‚™≠Ô∏Ä","lbarr":"‚§å","lBarr":"‚§é","lbbrk":"‚ù≤","lbrace":"{","lbrack":"[","lbrke":"‚¶ã","lbrksld":"‚¶è","lbrkslu":"‚¶ç","Lcaron":"ƒΩ","lcaron":"ƒæ","Lcedil":"ƒª","lcedil":"ƒº","lceil":"‚åà","lcub":"{","Lcy":"–õ","lcy":"–ª","ldca":"‚§∂","ldquo":"‚Äú","ldquor":"‚Äû","ldrdhar":"‚•ß","ldrushar":"‚•ã","ldsh":"‚Ü≤","le":"‚â§","lE":"‚â¶","LeftAngleBracket":"‚ü®","LeftArrowBar":"‚á§","leftarrow":"‚Üê","LeftArrow":"‚Üê","Leftarrow":"‚áê","LeftArrowRightArrow":"‚áÜ","leftarrowtail":"‚Ü¢","LeftCeiling":"‚åà","LeftDoubleBracket":"‚ü¶","LeftDownTeeVector":"‚•°","LeftDownVectorBar":"‚•ô","LeftDownVector":"‚áÉ","LeftFloor":"‚åä","leftharpoondown":"‚ÜΩ","leftharpoonup":"‚Üº","leftleftarrows":"‚áá","leftrightarrow":"‚Üî","LeftRightArrow":"‚Üî","Leftrightarrow":"‚áî","leftrightarrows":"‚áÜ","leftrightharpoons":"‚áã","leftrightsquigarrow":"‚Ü≠","LeftRightVector":"‚•é","LeftTeeArrow":"‚Ü§","LeftTee":"‚ä£","LeftTeeVector":"‚•ö","leftthreetimes":"‚ãã","LeftTriangleBar":"‚ßè","LeftTriangle":"‚ä≤","LeftTriangleEqual":"‚ä¥","LeftUpDownVector":"‚•ë","LeftUpTeeVector":"‚•†","LeftUpVectorBar":"‚•ò","LeftUpVector":"‚Üø","LeftVectorBar":"‚•í","LeftVector":"‚Üº","lEg":"‚™ã","leg":"‚ãö","leq":"‚â§","leqq":"‚â¶","leqslant":"‚©Ω","lescc":"‚™®","les":"‚©Ω","lesdot":"‚©ø","lesdoto":"‚™Å","lesdotor":"‚™É","lesg":"‚ãöÔ∏Ä"
¬© ","COPY":"¬©","curren":"¬§","deg":"¬∞","divide":"√∑","Eacute":"√â","eacute":"√©","Ecirc":"√ä","ecirc":"√™","Egrave":"√à","egrave":"√®","ETH":"√ê","eth":"√∞","Euml":"√ã","euml":"√´","frac12":"¬Ω","frac14":"¬º","frac34":"¬æ","gt":">","GT":">","Iacute":"√ç","iacute":"√≠","Icirc":"√é","icirc":"√Æ","iexcl":"¬°","Igrave":"√å","igrave":"√¨","iquest":"¬ø","Iuml":"√è","iuml":"√Ø","laquo":"¬´","lt":"<","LT":"<","macr":"¬Ø","micro":"¬µ","middot":"¬∑","nbsp":"¬†","not":"¬¨","Ntilde":"√ë","ntilde":"√±","Oacute":"√ì","oacute":"√≥","Ocirc":"√î","ocirc":"√¥","Ograve":"√í","ograve":"√≤","ordf":"¬™","ordm":"¬∫","Oslash":"√ò","oslash":"√∏","Otilde":"√ï","otilde":"√µ","Ouml":"√ñ","ouml":"√∂","para":"¬∂","plusmn":"¬±","pound":"¬£","quot":"\\"","QUOT":"\\"","raquo":"¬ª","reg":"¬Æ","REG":"¬Æ","sect":"¬ß","shy":"¬≠","sup1":"¬π","sup2":"¬≤","sup3":"¬≥","szlig":"√ü","THORN":"√û","thorn":"√æ","times":"√ó","Uacute":"√ö","uacute":"√∫","Ucirc":"√õ","ucirc":"√ª","Ugrave":"√ô","ugrave":"√π","uml":"¬®","Uuml":"√ú","uuml":"√º","Yacute":"√ù","yacute":"√Ω","yen":"¬•","yuml":"√ø"}');
¬© `, and `\+` does not match `+`.</text>

FileName: ./.github/actions/doctoc/dist/index.js.map
SPDXID: SPDXRef-4507561f425b645ff578d2dae60a1674
FileChecksum: SHA1: 28d37e3d9ff7002ce2624ecaa3e765bf26768e99
LicenseConcluded: NOASSERTION
FileCopyrightText: <text>Copyright 2010-2013 Sami Samhuri <sami@samhuri.net>\n//\n// MIT License\n// http://sjs.mit-license.org\n//\n\n;(function() {\n\n  //// Export the API\n  var namespace;\n\n  // CommonJS / Node module\n  if (typeof module !== 'undefined') {\n    namespace = module.exports = format;\n  }\n\n  // Browsers and other environments\n  else {\n    // Get the global object. Works in ES3, ES5, and ES5 strict mode.\n    namespace = (function(){ return this || (1,eval)('this') }());\n  }\n\n  namespace.format = format;\n  namespace.vsprintf = vsprintf;\n\n  if (typeof console !== 'undefined' && typeof console.log === 'function') {\n    namespace.printf = printf;\n  }\n\n  function printf(/* ... */) {\n    console.log(format.apply(null, arguments));\n  }\n\n  function vsprintf(fmt, replacements) {\n    return format.apply(null, [fmt].concat(replacements));\n  }\n\n  function format(fmt) {\n    var argIndex = 1 // skip initial format argument\n      , args = [].slice.call(arguments)\n      , i = 0\n      , n = fmt.length\n      , result = ''\n      , c\n      , escaped = false\n      , arg\n      , tmp\n      , leadingZero = false\n      , precision\n      , nextArg = function() { return args[argIndex++]; }\n      , slurpNumber = function() {\n          var digits = '';\n          while (/\\d/.test(fmt[i])) {\n            digits += fmt[i++];\n            c = fmt[i];\n          }\n          return digits.length > 0 ? parseInt(digits) : null;\n        }\n      ;\n    for (; i < n; ++i) {\n      c = fmt[i];\n      if (escaped) {\n        escaped = false;\n        if (c == '.') {\n          leadingZero = false;\n          c = fmt[++i];\n        }\n        else if (c == '0' && fmt[i + 1] == '.') {\n          leadingZero = true;\n          i += 2;\n          c = fmt[i];\n        }\n        else {\n          leadingZero = true;\n        }\n        precision = slurpNumber();\n        switch (c) {\n        case 'b': // number in binary\n          result += parseInt(nextArg(), 10).toString(2);\n          break;\n        case 'c': // character\n          arg = nextArg();\n          if (typeof arg === 'string' || arg instanceof String)\n            result += arg;\n          else\n            result += String.fromCharCode(parseInt(arg, 10));\n          break;\n        case 'd': // number in decimal\n          result += parseInt(nextArg(), 10);\n          break;\n        case 'f': // floating point number\n          tmp = String(parseFloat(nextArg()).toFixed(precision || 6));\n          result += leadingZero ? tmp : tmp.replace(/^0/, '');\n          break;\n        case 'j': // JSON\n          result += JSON.stringify(nextArg());\n          break;\n        case 'o': // number in octal\n          result += '0' + parseInt(nextArg(), 10).toString(8);\n          break;\n        case 's': // string\n          result += nextArg();\n          break;\n        case 'x': // lowercase hexadecimal\n          result += '0x' + parseInt(nextArg(), 10).toString(16);\n          break;\n        case 'X': // uppercase hexadecimal\n          result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();\n          break;\n        default:\n          result += c;\n          break;\n        }\n      } else if (c === '%') {\n        escaped = true;\n      } else {\n        result += c;\n      }\n    }\n    return result;\n  }\n\n}());\n","'use strict';\nmodule.exports = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseFeed = exports.FeedHandler = exports.getFeed = void 0;\nvar domhandler_1 = __importDefault(require(\"domhandler\"));\nvar domutils_1 = require(\"domutils\");\nObject.defineProperty(exports, \"getFeed\", { enumerable: true, get: function () { return domutils_1.getFeed; } });\nvar Parser_1 = require(\"./Parser\");\n/** @deprecated Handler is no longer necessary; use `getFeed` or `parseFeed` instead. */\nvar FeedHandler = /** @class */ (function (_super) {\n    __extends(FeedHandler, _super);\n    /**\n     *\n     * @param callback\n     * @param options\n     */\n    function FeedHandler(callback, options) {\n        var _this = this;\n        if (typeof callback === \"object\") {\n            callback = undefined;\n            options = callback;\n        }\n        _this = _super.call(this, callback, options) || this;\n        return _this;\n    }\n    FeedHandler.prototype.onend = function () {\n        var feed = (0, domutils_1.getFeed)(this.dom);\n        if (feed) {\n            this.feed = feed;\n            this.handleCallback(null);\n        }\n        else {\n            this.handleCallback(new Error(\"couldn't find root of feed\"));\n        }\n    };\n    return FeedHandler;\n}(domhandler_1.default));\nexports.FeedHandler = FeedHandler;\n/**\n * Parse a feed.\n *\n * @param feed The feed that should be parsed, as a string.\n * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.\n */\nfunction parseFeed(feed, options) {\n    if (options === void 0) { options = { xmlMode: true }; }\n    var handler = new domhandler_1.default(null, options);\n    new Parser_1.Parser(handler, options).end(feed);\n    return (0, domutils_1.getFeed)(handler.dom);\n}\nexports.parseFeed = parseFeed;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nvar Tokenizer_1 = __importDefault(require(\"./Tokenizer\"));\nvar formTags = new Set([\n    \"input\",\n    \"option\",\n    \"optgroup\",\n    \"select\",\n    \"button\",\n    \"datalist\",\n    \"textarea\",\n]);\nvar pTag = new Set([\"p\"]);\nvar tableSectionTags = new Set([\"thead\", \"tbody\"]);\nvar ddtTags = new Set([\"dd\", \"dt\"]);\nvar rtpTags = new Set([\"rt\", \"rp\"]);\nvar openImpliesClose = new Map([\n    [\"tr\", new Set([\"tr\", \"th\", \"td\"])],\n    [\"th\", new Set([\"th\"])],\n    [\"td\", new Set([\"thead\", \"th\", \"td\"])],\n    [\"body\", new Set([\"head\", \"link\", \"script\"])],\n    [\"li\", new Set([\"li\"])],\n    [\"p\", pTag],\n    [\"h1\", pTag],\n    [\"h2\", pTag],\n    [\"h3\", pTag],\n    [\"h4\", pTag],\n    [\"h5\", pTag],\n    [\"h6\", pTag],\n    [\"select\", formTags],\n    [\"input\", formTags],\n    [\"output\", formTags],\n    [\"button\", formTags],\n    [\"datalist\", formTags],\n    [\"textarea\", formTags],\n    [\"option\", new Set([\"option\"])],\n    [\"optgroup\", new Set([\"optgroup\", \"option\"])],\n    [\"dd\", ddtTags],\n    [\"dt\", ddtTags],\n    [\"address\", pTag],\n    [\"article\", pTag],\n    [\"aside\", pTag],\n    [\"blockquote\", pTag],\n    [\"details\", pTag],\n    [\"div\", pTag],\n    [\"dl\", pTag],\n    [\"fieldset\", pTag],\n    [\"figcaption\", pTag],\n    [\"figure\", pTag],\n    [\"footer\", pTag],\n    [\"form\", pTag],\n    [\"header\", pTag],\n    [\"hr\", pTag],\n    [\"main\", pTag],\n    [\"nav\", pTag],\n    [\"ol\", pTag],\n    [\"pre\", pTag],\n    [\"section\", pTag],\n    [\"table\", pTag],\n    [\"ul\", pTag],\n    [\"rt\", rtpTags],\n    [\"rp\", rtpTags],\n    [\"tbody\", tableSectionTags],\n    [\"tfoot\", tableSectionTags],\n]);\nvar voidElements = new Set([\n    \"area\",\n    \"base\",\n    \"basefont\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"frame\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"isindex\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n]);\nvar foreignContextElements = new Set([\"math\", \"svg\"]);\nvar htmlIntegrationElements = new Set([\n    \"mi\",\n    \"mo\",\n    \"mn\",\n    \"ms\",\n    \"mtext\",\n    \"annotation-xml\",\n    \"foreignobject\",\n    \"desc\",\n    \"title\",\n]);\nvar reNameEnd = /\\s|\\//;\nvar Parser = /** @class */ (function () {\n    function Parser(cbs, options) {\n        if (options === void 0) { options = {}; }\n        var _a, _b, _c, _d, _e;\n        this.options = options;\n        /** The start index of the last event. */\n        this.startIndex = 0;\n        /** The end index of the last event. */\n        this.endIndex = 0;\n        /**\n         * Store the start index of the current open tag,\n         * so we can update the start index for attributes.\n         */\n        this.openTagStart = 0;\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribvalue = \"\";\n        this.attribs = null;\n        this.stack = [];\n        this.foreignContext = [];\n        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};\n        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;\n        this.lowerCaseAttributeNames =\n            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;\n        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);\n        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);\n    }\n    // Tokenizer event handlers\n    /** @internal */\n    Parser.prototype.ontext = function (data) {\n        var _a, _b;\n        var idx = this.tokenizer.getAbsoluteIndex();\n        this.endIndex = idx - 1;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);\n        this.startIndex = idx;\n    };\n    Parser.prototype.isVoidElement = function (name) {\n        return !this.options.xmlMode && voidElements.has(name);\n    };\n    /** @internal */\n    Parser.prototype.onopentagname = function (name) {\n        this.endIndex = this.tokenizer.getAbsoluteIndex();\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        this.emitOpenTag(name);\n    };\n    Parser.prototype.emitOpenTag = function (name) {\n        var _a, _b, _c, _d;\n        this.openTagStart = this.startIndex;\n        this.tagname = name;\n        var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);\n        if (impliesClose) {\n            while (this.stack.length > 0 &&\n                impliesClose.has(this.stack[this.stack.length - 1])) {\n                var el = this.stack.pop();\n                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, el, true);\n            }\n        }\n        if (!this.isVoidElement(name)) {\n            this.stack.push(name);\n            if (foreignContextElements.has(name)) {\n                this.foreignContext.push(true);\n            }\n            else if (htmlIntegrationElements.has(name)) {\n                this.foreignContext.push(false);\n            }\n        }\n        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);\n        if (this.cbs.onopentag)\n            this.attribs = {};\n    };\n    Parser.prototype.endOpenTag = function (isImplied) {\n        var _a, _b;\n        this.startIndex = this.openTagStart;\n        this.endIndex = this.tokenizer.getAbsoluteIndex();\n        if (this.attribs) {\n            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);\n            this.attribs = null;\n        }\n        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {\n            this.cbs.onclosetag(this.tagname, true);\n        }\n        this.tagname = \"\";\n    };\n    /** @internal */\n    Parser.prototype.onopentagend = function () {\n        this.endOpenTag(false);\n        // Set `startIndex` for next node\n        this.startIndex = this.endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onclosetag = function (name) {\n        var _a, _b, _c, _d, _e, _f;\n        this.endIndex = this.tokenizer.getAbsoluteIndex();\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        if (foreignContextElements.has(name) ||\n            htmlIntegrationElements.has(name)) {\n            this.foreignContext.pop();\n        }\n        if (!this.isVoidElement(name)) {\n            var pos = this.stack.lastIndexOf(name);\n            if (pos !== -1) {\n                if (this.cbs.onclosetag) {\n                    var count = this.stack.length - pos;\n                    while (count--) {\n                        // We know the stack has sufficient elements.\n                        this.cbs.onclosetag(this.stack.pop(), count !== 0);\n                    }\n                }\n                else\n                    this.stack.length = pos;\n            }\n            else if (!this.options.xmlMode && name === \"p\") {\n                this.emitOpenTag(name);\n                this.closeCurrentTag(true);\n            }\n        }\n        else if (!this.options.xmlMode && name === \"br\") {\n            // We can't go through `emitOpenTag` here, as `br` would be implicitly closed.\n            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name);\n            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, name, {}, true);\n            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, name, false);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = this.endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onselfclosingtag = function () {\n        if (this.options.xmlMode ||\n            this.options.recognizeSelfClosing ||\n            this.foreignContext[this.foreignContext.length - 1]) {\n            this.closeCurrentTag(false);\n            // Set `startIndex` for next node\n            this.startIndex = this.endIndex + 1;\n        }\n        else {\n            // Ignore the fact that the tag is self-closing.\n            this.onopentagend();\n        }\n    };\n    Parser.prototype.closeCurrentTag = function (isOpenImplied) {\n        var _a, _b;\n        var name = this.tagname;\n        this.endOpenTag(isOpenImplied);\n        // Self-closing tags will be on the top of the stack\n        if (this.stack[this.stack.length - 1] === name) {\n            // If the opening tag isn't implied, the closing tag has to be implied.\n            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);\n            this.stack.pop();\n        }\n    };\n    /** @internal */\n    Parser.prototype.onattribname = function (name) {\n        this.startIndex = this.tokenizer.getAbsoluteSectionStart();\n        if (this.lowerCaseAttributeNames) {\n            name = name.toLowerCase();\n        }\n        this.attribname = name;\n    };\n    /** @internal */\n    Parser.prototype.onattribdata = function (value) {\n        this.attribvalue += value;\n    };\n    /** @internal */\n    Parser.prototype.onattribend = function (quote) {\n        var _a, _b;\n        this.endIndex = this.tokenizer.getAbsoluteIndex();\n        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);\n        if (this.attribs &&\n            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {\n            this.attribs[this.attribname] = this.attribvalue;\n        }\n        this.attribname = \"\";\n        this.attribvalue = \"\";\n    };\n    Parser.prototype.getInstructionName = function (value) {\n        var idx = value.search(reNameEnd);\n        var name = idx < 0 ? value : value.substr(0, idx);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        return name;\n    };\n    /** @internal */\n    Parser.prototype.ondeclaration = function (value) {\n        this.endIndex = this.tokenizer.getAbsoluteIndex();\n        if (this.cbs.onprocessinginstruction) {\n            var name_1 = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(\"!\" + name_1, \"!\" + value);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = this.endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onprocessinginstruction = function (value) {\n        this.endIndex = this.tokenizer.getAbsoluteIndex();\n        if (this.cbs.onprocessinginstruction) {\n            var name_2 = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(\"?\" + name_2, \"?\" + value);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = this.endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.oncomment = function (value) {\n        var _a, _b, _c, _d;\n        this.endIndex = this.tokenizer.getAbsoluteIndex();\n        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);\n        // Set `startIndex` for next node\n        this.startIndex = this.endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.oncdata = function (value) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        this.endIndex = this.tokenizer.getAbsoluteIndex();\n        if (this.options.xmlMode || this.options.recognizeCDATA) {\n            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);\n            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);\n            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);\n        }\n        else {\n            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, \"[CDATA[\" + value + \"]]\");\n            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = this.endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onerror = function (err) {\n        var _a, _b;\n        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    };\n    /** @internal */\n    Parser.prototype.onend = function () {\n        var _a, _b;\n        if (this.cbs.onclosetag) {\n            // Set the end index for all remaining tags\n            this.endIndex = this.startIndex;\n            for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true))\n                ;\n        }\n        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    /**\n     * Resets the parser to a blank state, ready to parse a new HTML document\n     */\n    Parser.prototype.reset = function () {\n        var _a, _b, _c, _d;\n        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.tokenizer.reset();\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribs = null;\n        this.stack = [];\n        this.startIndex = 0;\n        this.endIndex = 0;\n        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n    };\n    /**\n     * Resets the parser, then parses a complete document and\n     * pushes it to the handler.\n     *\n     * @param data Document to parse.\n     */\n    Parser.prototype.parseComplete = function (data) {\n        this.reset();\n        this.end(data);\n    };\n    /**\n     * Parses a chunk of data and calls the corresponding callbacks.\n     *\n     * @param chunk Chunk to parse.\n     */\n    Parser.prototype.write = function (chunk) {\n        this.tokenizer.write(chunk);\n    };\n    /**\n     * Parses the end of the buffer and clears the stack, calls onend.\n     *\n     * @param chunk Optional final chunk to parse.\n     */\n    Parser.prototype.end = function (chunk) {\n        this.tokenizer.end(chunk);\n    };\n    /**\n     * Pauses parsing. The parser won't emit events until `resume` is called.\n     */\n    Parser.prototype.pause = function () {\n        this.tokenizer.pause();\n    };\n    /**\n     * Resumes parsing after `pause` was called.\n     */\n    Parser.prototype.resume = function () {\n        this.tokenizer.resume();\n    };\n    /**\n     * Alias of `write`, for backwards compatibility.\n     *\n     * @param chunk Chunk to parse.\n     * @deprecated\n     */\n    Parser.prototype.parseChunk = function (chunk) {\n        this.write(chunk);\n    };\n    /**\n     * Alias of `end`, for backwards compatibility.\n     *\n     * @param chunk Optional final chunk to parse.\n     * @deprecated\n     */\n    Parser.prototype.done = function (chunk) {\n        this.end(chunk);\n    };\n    return Parser;\n}());\nexports.Parser = Parser;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar decode_codepoint_1 = __importDefault(require(\"entities/lib/decode_codepoint\"));\nvar decode_1 = require(\"entities/lib/decode\");\nfunction isWhitespace(c) {\n    return (c === 32 /* Space */ ||\n        c === 10 /* NewLine */ ||\n        c === 9 /* Tab */ ||\n        c === 12 /* FormFeed */ ||\n        c === 13 /* CarriageReturn */);\n}\nfunction isEndOfTagSection(c) {\n    return c === 47 /* Slash */ || c === 62 /* Gt */ || isWhitespace(c);\n}\nfunction isNumber(c) {\n    return c >= 48 /* Zero */ && c <= 57 /* Nine */;\n}\nfunction isASCIIAlpha(c) {\n    return ((c >= 97 /* LowerA */ && c <= 122 /* LowerZ */) ||\n        (c >= 65 /* UpperA */ && c <= 90 /* UpperZ */));\n}\n/**\n * Sequences used to match longer strings.\n *\n * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End\n * sequences with an increased offset.\n */\nvar Sequences = {\n    Cdata: new Uint16Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),\n    CdataEnd: new Uint16Array([0x5d, 0x5d, 0x3e]),\n    CommentEnd: new Uint16Array([0x2d, 0x2d, 0x3e]),\n    ScriptEnd: new Uint16Array([\n        0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,\n    ]),\n    StyleEnd: new Uint16Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),\n    TitleEnd: new Uint16Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`\n};\nvar Tokenizer = /** @class */ (function () {\n    function Tokenizer(_a, cbs) {\n        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;\n        this.cbs = cbs;\n        /** The current state the tokenizer is in. */\n        this._state = 1 /* Text */;\n        /** The read buffer. */\n        this.buffer = \"\";\n        /** The beginning of the section that is currently being read. */\n        this.sectionStart = 0;\n        /** The index within the buffer that we are currently looking at. */\n        this._index = 0;\n        /**\n         * Data that has already been processed will be removed from the buffer occasionally.\n         * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.\n         */\n        this.bufferOffset = 0;\n        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n        this.baseState = 1 /* Text */;\n        /** For special parsing behavior inside of script and style tags. */\n        this.isSpecial = false;\n        /** Indicates whether the tokenizer has been paused. */\n        this.running = true;\n        /** Indicates whether the tokenizer has finished running / `.end` has been called. */\n        this.ended = false;\n        this.sequenceIndex = 0;\n        this.trieIndex = 0;\n        this.trieCurrent = 0;\n        this.trieResult = null;\n        this.entityExcess = 0;\n        this.xmlMode = xmlMode;\n        this.decodeEntities = decodeEntities;\n        this.entityTrie = xmlMode ? decode_1.xmlDecodeTree : decode_1.htmlDecodeTree;\n    }\n    Tokenizer.prototype.reset = function () {\n        this._state = 1 /* Text */;\n        this.buffer = \"\";\n        this.sectionStart = 0;\n        this._index = 0;\n        this.bufferOffset = 0;\n        this.baseState = 1 /* Text */;\n        this.currentSequence = undefined;\n        this.running = true;\n        this.ended = false;\n    };\n    Tokenizer.prototype.write = function (chunk) {\n        if (this.ended)\n            return this.cbs.onerror(Error(\".write() after done!\"));\n        this.buffer += chunk;\n        this.parse();\n    };\n    Tokenizer.prototype.end = function (chunk) {\n        if (this.ended)\n            return this.cbs.onerror(Error(\".end() after done!\"));\n        if (chunk)\n            this.write(chunk);\n        this.ended = true;\n        if (this.running)\n            this.finish();\n    };\n    Tokenizer.prototype.pause = function () {\n        this.running = false;\n    };\n    Tokenizer.prototype.resume = function () {\n        this.running = true;\n        if (this._index < this.buffer.length) {\n            this.parse();\n        }\n        if (this.ended) {\n            this.finish();\n        }\n    };\n    /**\n     * The start of the current section.\n     */\n    Tokenizer.prototype.getAbsoluteSectionStart = function () {\n        return this.sectionStart + this.bufferOffset;\n    };\n    /**\n     * The current index within all of the written data.\n     */\n    Tokenizer.prototype.getAbsoluteIndex = function () {\n        return this.bufferOffset + this._index;\n    };\n    Tokenizer.prototype.stateText = function (c) {\n        if (c === 60 /* Lt */ ||\n            (!this.decodeEntities && this.fastForwardTo(60 /* Lt */))) {\n            if (this._index > this.sectionStart) {\n                this.cbs.ontext(this.getSection());\n            }\n            this._state = 2 /* BeforeTagName */;\n            this.sectionStart = this._index;\n        }\n        else if (this.decodeEntities && c === 38 /* Amp */) {\n            this._state = 25 /* BeforeEntity */;\n        }\n    };\n    Tokenizer.prototype.stateSpecialStartSequence = function (c) {\n        var isEnd = this.sequenceIndex === this.currentSequence.length;\n        var isMatch = isEnd\n            ? // If we are at the end of the sequence, make sure the tag name has ended\n                isEndOfTagSection(c)\n            : // Otherwise, do a case-insensitive comparison\n                (c | 0x20) === this.currentSequence[this.sequenceIndex];\n        if (!isMatch) {\n            this.isSpecial = false;\n        }\n        else if (!isEnd) {\n            this.sequenceIndex++;\n            return;\n        }\n        this.sequenceIndex = 0;\n        this._state = 3 /* InTagName */;\n        this.stateInTagName(c);\n    };\n    /** Look for an end tag. For <title> tags, also decode entities. */\n    Tokenizer.prototype.stateInSpecialTag = function (c) {\n        if (this.sequenceIndex === this.currentSequence.length) {\n            if (c === 62 /* Gt */ || isWhitespace(c)) {\n                var endOfText = this._index - this.currentSequence.length;\n                if (this.sectionStart < endOfText) {\n                    // Spoof the index so that reported locations match up.\n                    var actualIndex = this._index;\n                    this._index = endOfText;\n                    this.cbs.ontext(this.getSection());\n                    this._index = actualIndex;\n                }\n                this.isSpecial = false;\n                this.sectionStart = endOfText + 2; // Skip over the `</`\n                this.stateInClosingTagName(c);\n                return; // We are done; skip the rest of the function.\n            }\n            this.sequenceIndex = 0;\n        }\n        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {\n            this.sequenceIndex += 1;\n        }\n        else if (this.sequenceIndex === 0) {\n            if (this.currentSequence === Sequences.TitleEnd) {\n                // We have to parse entities in <title> tags.\n                if (this.decodeEntities && c === 38 /* Amp */) {\n                    this._state = 25 /* BeforeEntity */;\n                }\n            }\n            else if (this.fastForwardTo(60 /* Lt */)) {\n                // Outside of <title> tags, we can fast-forward.\n                this.sequenceIndex = 1;\n            }\n        }\n        else {\n            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.\n            this.sequenceIndex = Number(c === 60 /* Lt */);\n        }\n    };\n    Tokenizer.prototype.stateCDATASequence = function (c) {\n        if (c === Sequences.Cdata[this.sequenceIndex]) {\n            if (++this.sequenceIndex === Sequences.Cdata.length) {\n                this._state = 21 /* InCommentLike */;\n                this.currentSequence = Sequences.CdataEnd;\n                this.sequenceIndex = 0;\n                this.sectionStart = this._index + 1;\n            }\n        }\n        else {\n            this.sequenceIndex = 0;\n            this._state = 16 /* InDeclaration */;\n            this.stateInDeclaration(c); // Reconsume the character\n        }\n    };\n    /**\n     * When we wait for one specific character, we can speed things up\n     * by skipping through the buffer until we find it.\n     *\n     * @returns Whether the character was found.\n     */\n    Tokenizer.prototype.fastForwardTo = function (c) {\n        while (++this._index < this.buffer.length) {\n            if (this.buffer.charCodeAt(this._index) === c) {\n                return true;\n            }\n        }\n        /*\n         * We increment the index at the end of the `parse` loop,\n         * so set it to `buffer.length - 1` here.\n         *\n         * TODO: Refactor `parse` to increment index before calling states.\n         */\n        this._index = this.buffer.length - 1;\n        return false;\n    };\n    /**\n     * Comments and CDATA end with `-->` and `]]>`.\n     *\n     * Their common qualities are:\n     * - Their end sequences have a distinct character they start with.\n     * - That character is then repeated, so we have to check multiple repeats.\n     * - All characters but the start character of the sequence can be skipped.\n     */\n    Tokenizer.prototype.stateInCommentLike = function (c) {\n        if (c === this.currentSequence[this.sequenceIndex]) {\n            if (++this.sequenceIndex === this.currentSequence.length) {\n                // Remove 2 trailing chars\n                var section = this.buffer.slice(this.sectionStart, this._index - 2);\n                if (this.currentSequence === Sequences.CdataEnd) {\n                    this.cbs.oncdata(section);\n                }\n                else {\n                    this.cbs.oncomment(section);\n                }\n                this.sequenceIndex = 0;\n                this.sectionStart = this._index + 1;\n                this._state = 1 /* Text */;\n            }\n        }\n        else if (this.sequenceIndex === 0) {\n            // Fast-forward to the first character of the sequence\n            if (this.fastForwardTo(this.currentSequence[0])) {\n                this.sequenceIndex = 1;\n            }\n        }\n        else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\n            // Allow long sequences, eg. --->, ]]]>\n            this.sequenceIndex = 0;\n        }\n    };\n    /**\n     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n     *\n     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n     * We allow anything that wouldn't end the tag.\n     */\n    Tokenizer.prototype.isTagStartChar = function (c) {\n        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);\n    };\n    Tokenizer.prototype.startSpecial = function (sequence, offset) {\n        this.isSpecial = true;\n        this.currentSequence = sequence;\n        this.sequenceIndex = offset;\n        this._state = 23 /* SpecialStartSequence */;\n    };\n    Tokenizer.prototype.stateBeforeTagName = function (c) {\n        if (c === 33 /* ExclamationMark */) {\n            this._state = 15 /* BeforeDeclaration */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (c === 63 /* Questionmark */) {\n            this._state = 17 /* InProcessingInstruction */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (this.isTagStartChar(c)) {\n            var lower = c | 0x20;\n            this.sectionStart = this._index;\n            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {\n                this.startSpecial(Sequences.TitleEnd, 3);\n            }\n            else {\n                this._state =\n                    !this.xmlMode && lower === Sequences.ScriptEnd[2]\n                        ? 22 /* BeforeSpecialS */\n                        : 3 /* InTagName */;\n            }\n        }\n        else if (c === 47 /* Slash */) {\n            this._state = 5 /* BeforeClosingTagName */;\n        }\n        else {\n            this._state = 1 /* Text */;\n            this.stateText(c);\n        }\n    };\n    Tokenizer.prototype.stateInTagName = function (c) {\n        if (isEndOfTagSection(c)) {\n            this.cbs.onopentagname(this.getSection());\n            this.sectionStart = -1;\n            this._state = 8 /* BeforeAttributeName */;\n            this.stateBeforeAttributeName(c);\n        }\n    };\n    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {\n        if (isWhitespace(c)) {\n            // Ignore\n        }\n        else if (c === 62 /* Gt */) {\n            this._state = 1 /* Text */;\n        }\n        else {\n            this._state = this.isTagStartChar(c)\n                ? 6 /* InClosingTagName */\n                : 20 /* InSpecialComment */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateInClosingTagName = function (c) {\n        if (c === 62 /* Gt */ || isWhitespace(c)) {\n            this.cbs.onclosetag(this.getSection());\n            this.sectionStart = -1;\n            this._state = 7 /* AfterClosingTagName */;\n            this.stateAfterClosingTagName(c);\n        }\n    };\n    Tokenizer.prototype.stateAfterClosingTagName = function (c) {\n        // Skip everything until \">\"\n        if (c === 62 /* Gt */ || this.fastForwardTo(62 /* Gt */)) {\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n    };\n    Tokenizer.prototype.stateBeforeAttributeName = function (c) {\n        if (c === 62 /* Gt */) {\n            this.cbs.onopentagend();\n            if (this.isSpecial) {\n
Copyright (C) 2014-2015 Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Results cache\n */\n\nvar res = '';\nvar cache;\n\n/**\n * Expose `repeat`\n */\n\nmodule.exports = repeat;\n\n/**\n * Repeat the given `string` the specified `number`\n * of times.\n *\n * **Example:**\n *\n * ```js\n * var repeat = require('repeat-string');\n * repeat('A', 5);\n * //=> AAAAA\n * ```\n *\n * @param {String} `string` The string to repeat\n * @param {Number} `number` The number of times to repeat the string\n * @return {String} Repeated string\n * @api public\n */\n\nfunction repeat(str, num) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  // cover common, quick use cases\n  if (num === 1) return str;\n  if (num === 2) return str + str;\n\n  var max = str.length * num;\n  if (cache !== str || typeof cache === 'undefined') {\n    cache = str;\n    res = '';\n  } else if (res.length >= max) {\n    return res.substr(0, max);\n  }\n\n  while (max > res.length && num > 1) {\n    if (num & 1) {\n      res += str;\n    }\n\n    num >>= 1;\n    str += str;\n  }\n\n  res += str;\n  res = res.substr(0, max);\n  return res;\n}\n","'use strict';\nconst os = require('os');\nconst hasFlag = require('has-flag');\n\nconst env = process.env;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor ? 1 : 0;\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors. Windows 10 build 14931 is the first release\n\t\t// that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\n","var traverse = module.exports = function (obj) {\n    return new Traverse(obj);\n};\n\nfunction Traverse (obj) {\n    this.value = obj;\n}\n\nTraverse.prototype.get = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!node || !hasOwnProperty.call(node, key)) {\n            node = undefined;\n            break;\n        }\n        node = node[key];\n    }\n    return node;\n};\n\nTraverse.prototype.has = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!node || !hasOwnProperty.call(node, key)) {\n            return false;\n        }\n        node = node[key];\n    }\n    return true;\n};\n\nTraverse.prototype.set = function (ps, value) {\n    var node = this.value;\n    for (var i = 0; i < ps.length - 1; i ++) {\n        var key = ps[i];\n        if (!hasOwnProperty.call(node, key)) node[key] = {};\n        node = node[key];\n    }\n    node[ps[i]] = value;\n    return value;\n};\n\nTraverse.prototype.map = function (cb) {\n    return walk(this.value, cb, true);\n};\n\nTraverse.prototype.forEach = function (cb) {\n    this.value = walk(this.value, cb, false);\n    return this.value;\n};\n\nTraverse.prototype.reduce = function (cb, init) {\n    var skip = arguments.length === 1;\n    var acc = skip ? this.value : init;\n    this.forEach(function (x) {\n        if (!this.isRoot || !skip) {\n            acc = cb.call(this, acc, x);\n        }\n    });\n    return acc;\n};\n\nTraverse.prototype.paths = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.path); \n    });\n    return acc;\n};\n\nTraverse.prototype.nodes = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.node);\n    });\n    return acc;\n};\n\nTraverse.prototype.clone = function () {\n    var parents = [], nodes = [];\n    \n    return (function clone (src) {\n        for (var i = 0; i < parents.length; i++) {\n            if (parents[i] === src) {\n                return nodes[i];\n            }\n        }\n        \n        if (typeof src === 'object' && src !== null) {\n            var dst = copy(src);\n            \n            parents.push(src);\n            nodes.push(dst);\n            \n            forEach(objectKeys(src), function (key) {\n                dst[key] = clone(src[key]);\n            });\n            \n            parents.pop();\n            nodes.pop();\n            return dst;\n        }\n        else {\n            return src;\n        }\n    })(this.value);\n};\n\nfunction walk (root, cb, immutable) {\n    var path = [];\n    var parents = [];\n    var alive = true;\n    \n    return (function walker (node_) {\n        var node = immutable ? copy(node_) : node_;\n        var modifiers = {};\n        \n        var keepGoing = true;\n        \n        var state = {\n            node : node,\n            node_ : node_,\n            path : [].concat(path),\n            parent : parents[parents.length - 1],\n            parents : parents,\n            key : path.slice(-1)[0],\n            isRoot : path.length === 0,\n            level : path.length,\n            circular : null,\n            update : function (x, stopHere) {\n                if (!state.isRoot) {\n                    state.parent.node[state.key] = x;\n                }\n                state.node = x;\n                if (stopHere) keepGoing = false;\n            },\n            'delete' : function (stopHere) {\n                delete state.parent.node[state.key];\n                if (stopHere) keepGoing = false;\n            },\n            remove : function (stopHere) {\n                if (isArray(state.parent.node)) {\n                    state.parent.node.splice(state.key, 1);\n                }\n                else {\n                    delete state.parent.node[state.key];\n                }\n                if (stopHere) keepGoing = false;\n            },\n            keys : null,\n            before : function (f) { modifiers.before = f },\n            after : function (f) { modifiers.after = f },\n            pre : function (f) { modifiers.pre = f },\n            post : function (f) { modifiers.post = f },\n            stop : function () { alive = false },\n            block : function () { keepGoing = false }\n        };\n        \n        if (!alive) return state;\n        \n        function updateState() {\n            if (typeof state.node === 'object' && state.node !== null) {\n                if (!state.keys || state.node_ !== state.node) {\n                    state.keys = objectKeys(state.node)\n                }\n                \n                state.isLeaf = state.keys.length == 0;\n                \n                for (var i = 0; i < parents.length; i++) {\n                    if (parents[i].node_ === node_) {\n                        state.circular = parents[i];\n                        break;\n                    }\n                }\n            }\n            else {\n                state.isLeaf = true;\n                state.keys = null;\n            }\n            \n            state.notLeaf = !state.isLeaf;\n            state.notRoot = !state.isRoot;\n        }\n        \n        updateState();\n        \n        // use return values to update if defined\n        var ret = cb.call(state, state.node);\n        if (ret !== undefined && state.update) state.update(ret);\n        \n        if (modifiers.before) modifiers.before.call(state, state.node);\n        \n        if (!keepGoing) return state;\n        \n        if (typeof state.node == 'object'\n        && state.node !== null && !state.circular) {\n            parents.push(state);\n            \n            updateState();\n            \n            forEach(state.keys, function (key, i) {\n                path.push(key);\n                \n                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);\n                \n                var child = walker(state.node[key]);\n                if (immutable && hasOwnProperty.call(state.node, key)) {\n                    state.node[key] = child.node;\n                }\n                \n                child.isLast = i == state.keys.length - 1;\n                child.isFirst = i == 0;\n                \n                if (modifiers.post) modifiers.post.call(state, child);\n                \n                path.pop();\n            });\n            parents.pop();\n        }\n        \n        if (modifiers.after) modifiers.after.call(state, state.node);\n        \n        return state;\n    })(root).node;\n}\n\nfunction copy (src) {\n    if (typeof src === 'object' && src !== null) {\n        var dst;\n        \n        if (isArray(src)) {\n            dst = [];\n        }\n        else if (isDate(src)) {\n            dst = new Date(src.getTime ? src.getTime() : src);\n        }\n        else if (isRegExp(src)) {\n            dst = new RegExp(src);\n        }\n        else if (isError(src)) {\n            dst = { message: src.message };\n        }\n        else if (isBoolean(src)) {\n            dst = new Boolean(src);\n        }\n        else if (isNumber(src)) {\n            dst = new Number(src);\n        }\n        else if (isString(src)) {\n            dst = new String(src);\n        }\n        else if (Object.create && Object.getPrototypeOf) {\n            dst = Object.create(Object.getPrototypeOf(src));\n        }\n        else if (src.constructor === Object) {\n            dst = {};\n        }\n        else {\n            var proto =\n                (src.constructor && src.constructor.prototype)\n                || src.__proto__\n                || {}\n            ;\n            var T = function () {};\n            T.prototype = proto;\n            dst = new T;\n        }\n        \n        forEach(objectKeys(src), function (key) {\n            dst[key] = src[key];\n        });\n        return dst;\n    }\n    else return src;\n}\n\nvar objectKeys = Object.keys || function keys (obj) {\n    var res = [];\n    for (var key in obj) res.push(key)\n    return res;\n};\n\nfunction toS (obj) { return Object.prototype.toString.call(obj) }\nfunction isDate (obj) { return toS(obj) === '[object Date]' }\nfunction isRegExp (obj) { return toS(obj) === '[object RegExp]' }\nfunction isError (obj) { return toS(obj) === '[object Error]' }\nfunction isBoolean (obj) { return toS(obj) === '[object Boolean]' }\nfunction isNumber (obj) { return toS(obj) === '[object Number]' }\nfunction isString (obj) { return toS(obj) === '[object String]' }\n\nvar isArray = Array.isArray || function isArray (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nforEach(objectKeys(Traverse.prototype), function (key) {\n    traverse[key] = function (obj) {\n        var args = [].slice.call(arguments, 1);\n        var t = new Traverse(obj);\n        return t[key].apply(t, args);\n    };\n});\n\nvar hasOwnProperty = Object.hasOwnProperty || function (obj, key) {\n    return key in obj;\n};\n","'use strict'\n\nvar wrap = require('./wrap.js')\n\nmodule.exports = trough\n\ntrough.wrap = wrap\n\nvar slice = [].slice\n\n// Create new middleware.\nfunction trough() {\n  var fns = []\n  var middleware = {}\n\n  middleware.run = run\n  middleware.use = use\n\n  return middleware\n\n  // Run `fns`.  Last argument must be a completion handler.\n  function run() {\n    var index = -1\n    var input = slice.call(arguments, 0, -1)\n    var done = arguments[arguments.length - 1]\n\n    if (typeof done !== 'function') {\n      throw new Error('Expected function as last argument, not ' + done)\n    }\n\n    next.apply(null, [null].concat(input))\n\n    // Run the next `fn`, if any.\n    function next(err) {\n      var fn = fns[++index]\n      var params = slice.call(arguments, 0)\n      var values = params.slice(1)\n      var length = input.length\n      var pos = -1\n\n      if (err) {\n        done(err)\n        return\n      }\n\n      // Copy non-nully input into values.\n      while (++pos < length) {\n        if (values[pos] === null || values[pos] === undefined) {\n          values[pos] = input[pos]\n        }\n      }\n\n      input = values\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next).apply(null, input)\n      } else {\n        done.apply(null, [null].concat(input))\n      }\n    }\n  }\n\n  // Add `fn` to the list.\n  function use(fn) {\n    if (typeof fn !== 'function') {\n      throw new Error('Expected `fn` to be a function, not ' + fn)\n    }\n\n    fns.push(fn)\n\n    return middleware\n  }\n}\n","'use strict'\n\nvar slice = [].slice\n\nmodule.exports = wrap\n\n// Wrap `fn`.\n// Can be sync or async; return a promise, receive a completion handler, return\n// new values and errors.\nfunction wrap(fn, callback) {\n  var invoked\n\n  return wrapped\n\n  function wrapped() {\n    var params = slice.call(arguments, 0)\n    var callback = fn.length > params.length\n    var result\n\n    if (callback) {\n      params.push(done)\n    }\n\n    try {\n      result = fn.apply(null, params)\n    } catch (error) {\n      // Well, this is quite the pickle.\n      // `fn` received a callback and invoked it (thus continuing the pipeline),\n      // but later also threw an error.\n      // We‚Äôre not about to restart the pipeline again, so the only thing left\n      // to do is to throw the thing instead.\n      if (callback && invoked) {\n        throw error\n      }\n\n      return done(error)\n    }\n\n    if (!callback) {\n      if (result && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  // Invoke `next`, only once.\n  function done() {\n    if (!invoked) {\n      invoked = true\n\n      callback.apply(null, arguments)\n    }\n  }\n\n  // Invoke `done` with one value.\n  // Tracks if an error is passed, too.\n  function then(value) {\n    done(null, value)\n  }\n}\n","'use strict'\n\nvar bail = require('bail')\nvar buffer = require('is-buffer')\nvar extend = require('extend')\nvar plain = require('is-plain-obj')\nvar trough = require('trough')\nvar vfile = require('vfile')\n\n// Expose a frozen processor.\nmodule.exports = unified().freeze()\n\nvar slice = [].slice\nvar own = {}.hasOwnProperty\n\n// Process pipeline.\nvar pipeline = trough()\n  .use(pipelineParse)\n  .use(pipelineRun)\n  .use(pipelineStringify)\n\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file)\n}\n\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done)\n\n  function done(error, tree, file) {\n    if (error) {\n      next(error)\n    } else {\n      ctx.tree = tree\n      ctx.file = file\n      next()\n    }\n  }\n}\n\nfunction pipelineStringify(p, ctx) {\n  var result = p.stringify(ctx.tree, ctx.file)\n\n  if (result === undefined || result === null) {\n    // Empty.\n  } else if (typeof result === 'string' || buffer(result)) {\n    if ('value' in ctx.file) {\n      ctx.file.value = result\n    }\n\n    ctx.file.contents = result\n  } else {\n    ctx.file.result = result\n  }\n}\n\n// Function to create the first processor.\nfunction unified() {\n  var attachers = []\n  var transformers = trough()\n  var namespace = {}\n  var freezeIndex = -1\n  var frozen\n\n  // Data management.\n  processor.data = data\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  processor.run = run\n  processor.runSync = runSync\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  function processor() {\n    var destination = unified()\n    var index = -1\n\n    while (++index < attachers.length) {\n      destination.use.apply(null, attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  // Freeze: used to signal a processor that has finished configuration.\n  //\n  // For example, take unified itself: it‚Äôs frozen.\n  // Plugins should not be added to it.\n  // Rather, it should be extended, by invoking it, before modifying it.\n  //\n  // In essence, always invoke this when exporting a processor.\n  function freeze() {\n    var values\n    var transformer\n\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex]\n\n      if (values[1] === false) {\n        continue\n      }\n\n      if (values[1] === true) {\n        values[1] = undefined\n      }\n\n      transformer = values[0].apply(processor, values.slice(1))\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Infinity\n\n    return processor\n  }\n\n  // Data management.\n  // Getter / setter for processor-specific informtion.\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  // Plugin management.\n  //\n  // Pass it:\n  // *   an attacher and options,\n  // *   a preset,\n  // *   a list of presets, attachers, and arguments (list of attachers and\n  //     options).\n  function use(value) {\n    var settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments)\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings)\n      }\n    }\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    function addList(plugins) {\n      var index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        while (++index < plugins.length) {\n          add(plugins[index])\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    function addPlugin(plugin, value) {\n      var entry = find(plugin)\n\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        attachers.push(slice.call(arguments))\n      }\n    }\n  }\n\n  function find(plugin) {\n    var index = -1\n\n    while (++index < attachers.length) {\n      if (attachers[index][0] === plugin) {\n        return attachers[index]\n      }\n    }\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor.\n  function parse(doc) {\n    var file = vfile(doc)\n    var Parser\n\n    freeze()\n    Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      return new Parser(String(file), file).parse()\n    }\n\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), async.\n  function run(node, file, cb) {\n    assertNode(node)\n    freeze()\n\n    if (!cb && typeof file === 'function') {\n      cb = file\n      file = null\n    }\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done)\n\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          cb(null, tree, file)\n        }\n      }\n    }\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), sync.\n  function runSync(node, file) {\n    var result\n    var complete\n\n    run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    return result\n\n    function done(error, tree) {\n      complete = true\n      result = tree\n      bail(error)\n    }\n  }\n\n  // Stringify a unist node representation of a file (in string or vfile\n  // representation) into a string using the `Compiler` on the processor.\n  function stringify(node, doc) {\n    var file = vfile(doc)\n    var Compiler\n\n    freeze()\n    Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      return new Compiler(node, file).compile()\n    }\n\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor, then run transforms on that node, and\n  // compile the resulting node using the `Compiler` on the processor, and\n  // store that result on the vfile.\n  function process(doc, cb) {\n    freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      var file = vfile(doc)\n\n      pipeline.run(processor, {file: file}, done)\n\n      function done(error) {\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          cb(null, file)\n        }\n      }\n    }\n  }\n\n  // Process the given document (in string or vfile representation), sync.\n  function processSync(doc) {\n    var file\n    var complete\n\n    freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n    file = vfile(doc)\n\n    process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n// Check if `value` is a constructor.\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes‚Äô prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n// Check if `value` is an object with keys.\nfunction keys(value) {\n  var key\n  for (key in value) {\n    return true\n  }\n\n  return false\n}\n\n// Assert a parser is available.\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n// Assert a compiler is available.\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n// Assert the processor is not frozen.\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot invoke `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n// Assert `node` is a unist node.\nfunction assertNode(node) {\n  if (!node || typeof node.type !== 'string') {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n}\n\n// Assert that `complete` is `true`.\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n","'use strict'\n\nmodule.exports = convert\n\nfunction convert(test) {\n  if (test == null) {\n    return ok\n  }\n\n  if (typeof test === 'string') {\n    return typeFactory(test)\n  }\n\n  if (typeof test === 'object') {\n    return 'length' in test ? anyFactory(test) : allFactory(test)\n  }\n\n  if (typeof test === 'function') {\n    return test\n  }\n\n  throw new Error('Expected function, string, or object as test')\n}\n\n// Utility assert each property in `test` is represented in `node`, and each\n// values are strictly equal.\nfunction allFactory(test) {\n  return all\n\n  function all(node) {\n    var key\n\n    for (key in test) {\n      if (node[key] !== test[key]) return false\n    }\n\n    return true\n  }\n}\n\nfunction anyFactory(tests) {\n  var checks = []\n  var index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return any\n\n  function any() {\n    var index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, arguments)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n// Utility to convert a string into a function which checks a given node‚Äôs type\n// for said string.\nfunction typeFactory(test) {\n  return type\n\n  function type(node) {\n    return Boolean(node && node.type === test)\n  }\n}\n\n// Utility to return true.\nfunction ok() {\n  return true\n}\n","'use strict'\n\nvar own = {}.hasOwnProperty\n\nmodule.exports = stringify\n\nfunction stringify(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if (own.call(value, 'position') || own.call(value, 'type')) {\n    return position(value.position)\n  }\n\n  // Position.\n  if (own.call(value, 'start') || own.call(value, 'end')) {\n    return position(value)\n  }\n\n  // Point.\n  if (own.call(value, 'line') || own.call(value, 'column')) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\nfunction point(point) {\n  if (!point || typeof point !== 'object') {\n    point = {}\n  }\n\n  return index(point.line) + ':' + index(point.column)\n}\n\nfunction position(pos) {\n  if (!pos || typeof pos !== 'object') {\n    pos = {}\n  }\n\n  return point(pos.start) + '-' + point(pos.end)\n}\n\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","module.exports = color\nfunction color(d) {\n  return '\\u001B[33m' + d + '\\u001B[39m'\n}\n","'use strict'\n\nmodule.exports = visitParents\n\nvar convert = require('unist-util-is/convert')\nvar color = require('./color')\n\nvar CONTINUE = true\nvar SKIP = 'skip'\nvar EXIT = false\n\nvisitParents.CONTINUE = CONTINUE\nvisitParents.SKIP = SKIP\nvisitParents.EXIT = EXIT\n\nfunction visitParents(tree, test, visitor, reverse) {\n  var step\n  var is\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    visitor = test\n    test = null\n  }\n\n  is = convert(test)\n  step = reverse ? -1 : 1\n\n  factory(tree, null, [])()\n\n  function factory(node, index, parents) {\n    var value = typeof node === 'object' && node !== null ? node : {}\n    var name\n\n    if (typeof value.type === 'string') {\n      name =\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      visit.displayName =\n        'node (' + color(value.type + (name ? '<' + name + '>' : '')) + ')'\n    }\n\n    return visit\n\n    function visit() {\n      var grandparents = parents.concat(node)\n      var result = []\n      var subresult\n      var offset\n\n      if (!test || is(node, index, parents[parents.length - 1] || null)) {\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if (node.children && result[0] !== SKIP) {\n        offset = (reverse ? node.children.length : -1) + step\n\n        while (offset > -1 && offset < node.children.length) {\n          subresult = factory(node.children[offset], offset, grandparents)()\n\n          if (subresult[0] === EXIT) {\n            return subresult\n          }\n\n          offset =\n            typeof subresult[1] === 'number' ? subresult[1] : offset + step\n        }\n      }\n\n      return result\n    }\n  }\n}\n\nfunction toResult(value) {\n  if (value !== null && typeof value === 'object' && 'length' in value) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","'use strict';\n\n/**\n * Finds the start and end lines that match the given criteria.\n * Used by update-section itself.\n *\n * Use it if you need to get information about where the matching content is located.\n *\n * @name updateSection::parse\n * @function\n * @param {Array.<string>} lines the lines in which to look for matches\n * @param {Function} matchesStart when called with a line needs to return true iff it is the section start line\n * @param {Function} matchesEnd when called with a line needs to return true iff it is the section end line\n * @return {object} with the following properties: hasStart, hasEnd, startIdx, endIdx \n */\nfunction parse(lines, matchesStart, matchesEnd) {\n  var startIdx = -1\n    , endIdx = -1\n    , hasStart = false\n    , hasEnd = false\n    , line;\n\n  for (var i = 0; i < lines.length; i++) {\n    line = lines[i]\n    if (!hasStart && matchesStart(line)) { \n      startIdx = i;\n      hasStart = true;\n    } else if (!hasEnd && matchesEnd(line)) {\n      endIdx = i;\n      hasEnd = true;\n    }\n    if (hasStart && hasEnd) break;\n  }\n\n  // no end, correct it to be all remaining lines after start\n  if (!hasEnd) {\n    endIdx = lines.length;\n    hasEnd = true;\n  }\n\n  return { hasStart: hasStart, hasEnd: hasEnd, startIdx: startIdx, endIdx: endIdx };\n}\n\n/**\n * Updates the content with the given section. \n *\n * If previous section is found it is replaced.\n * Otherwise the section is appended to the end of the content.\n *\n * @name updateSection\n * @function\n * @param {String} content that may or may not include a previously added section\n * @param {String} section the section to update\n * @param {Function} matchesStart when called with a line needs to return true iff it is the section start line\n * @param {Function} matchesEnd when called with a line needs to return true iff it is the section end line\n * @param {boolean} top forces the section to be added at the top of the content if a replacement couldn't be made\n * @return {String} content with updated section\n */\nexports = module.exports = function updateSection(content, section, matchesStart, matchesEnd, top) {\n  if (!content) return section;\n\n  var lines = content.split('\\n')\n  if (!lines.length) return section;\n\n  var info = parse(lines, matchesStart, matchesEnd);\n\n  // no previous section found in content not just append\n  if (!info.hasStart) return top ? section + '\\n\\n' + content : content + '\\n\\n' + section;\n\n  var sectionLines = section.split('\\n')\n    , dropN = info.endIdx - info.startIdx + 1;\n\n  [].splice.apply(lines, [ info.startIdx, dropN ].concat(sectionLines))\n\n  return lines.join('\\n');\n}\n\nexports.parse = parse;\n","'use strict'\n\nvar stringify = require('unist-util-stringify-position')\n\nmodule.exports = VMessage\n\n// Inherit from `Error#`.\nfunction VMessagePrototype() {}\nVMessagePrototype.prototype = Error.prototype\nVMessage.prototype = new VMessagePrototype()\n\n// Message properties.\nvar proto = VMessage.prototype\n\nproto.file = ''\nproto.name = ''\nproto.reason = ''\nproto.message = ''\nproto.stack = ''\nproto.fatal = null\nproto.column = null\nproto.line = null\n\n// Construct a new VMessage.\n//\n// Note: We cannot invoke `Error` on the created context, as that adds readonly\n// `line` and `column` attributes on Safari 9, thus throwing and failing the\n// data.\nfunction VMessage(reason, position, origin) {\n  var parts\n  var range\n  var location\n\n  if (typeof position === 'string') {\n    origin = position\n    position = null\n  }\n\n  parts = parseOrigin(origin)\n  range = stringify(position) || '1:1'\n\n  location = {\n    start: {line: null, column: null},\n    end: {line: null, column: null}\n  }\n\n  // Node.\n  if (position && position.position) {\n    position = position.position\n  }\n\n  if (position) {\n    // Position.\n    if (position.start) {\n      location = position\n      position = position.start\n    } else {\n      // Point.\n      location.start = position\n    }\n  }\n\n  if (reason.stack) {\n    this.stack = reason.stack\n    reason = reason.message\n  }\n\n  this.message = reason\n  this.name = range\n  this.reason = reason\n  this.line = position ? position.line : null\n  this.column = position ? position.column : null\n  this.location = location\n  this.source = parts[0]\n  this.ruleId = parts[1]\n}\n\nfunction parseOrigin(origin) {\n  var result = [null, null]\n  var index\n\n  if (typeof origin === 'string') {\n    index = origin.indexOf(':')\n\n    if (index === -1) {\n      result[1] = origin\n    } else {\n      result[0] = origin.slice(0, index)\n      result[1] = origin.slice(index + 1)\n    }\n  }\n\n  return result\n}\n","'use strict'\n\nmodule.exports = require('./lib')\n","'use strict'\n\nvar p = require('./minpath')\nvar proc = require('./minproc')\nvar buffer = require('is-buffer')\n\nmodule.exports = VFile\n\nvar own = {}.hasOwnProperty\n\n// Order of setting (least specific to most), we need this because otherwise\n// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n// stem can be set.\nvar order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nVFile.prototype.toString = toString\n\n// Access full path (`~/index.min.js`).\nObject.defineProperty(VFile.prototype, 'path', {get: getPath, set: setPath})\n\n// Access parent path (`~`).\nObject.defineProperty(VFile.prototype, 'dirname', {\n  get: getDirname,\n  set: setDirname\n})\n\n// Access basename (`index.min.js`).\nObject.defineProperty(VFile.prototype, 'basename', {\n  get: getBasename,\n  set: setBasename\n})\n\n// Access extname (`.js`).\nObject.defineProperty(VFile.prototype, 'extname', {\n  get: getExtname,\n  set: setExtname\n})\n\n// Access stem (`index.min`).\nObject.defineProperty(VFile.prototype, 'stem', {get: getStem, set: setStem})\n\n// Construct a new file.\nfunction VFile(options) {\n  var prop\n  var index\n\n  if (!options) {\n    options = {}\n  } else if (typeof options === 'string' || buffer(options)) {\n    options = {contents: options}\n  } else if ('message' in options && 'messages' in options) {\n    return options\n  }\n\n  if (!(this instanceof VFile)) {\n    return new VFile(options)\n  }\n\n  this.data = {}\n  this.messages = []\n  this.history = []\n  this.cwd = proc.cwd()\n\n  // Set path related properties in the correct order.\n  index = -1\n\n  while (++index < order.length) {\n    prop = order[index]\n\n    if (own.call(options, prop)) {\n      this[prop] = options[prop]\n    }\n  }\n\n  // Set non-path related properties.\n  for (prop in options) {\n    if (order.indexOf(prop) < 0) {\n      this[prop] = options[prop]\n    }\n  }\n}\n\nfunction getPath() {\n  return this.history[this.history.length - 1]\n}\n\nfunction setPath(path) {\n  assertNonEmpty(path, 'path')\n\n  if (this.path !== path) {\n    this.history.push(path)\n  }\n}\n\nfunction getDirname() {\n  return typeof this.path === 'string' ? p.dirname(this.path) : undefined\n}\n\nfunction setDirname(dirname) {\n  assertPath(this.path, 'dirname')\n  this.path = p.join(dirname || '', this.basename)\n}\n\nfunction getBasename() {\n  return typeof this.path === 'string' ? p.basename(this.path) : undefined\n}\n\nfunction setBasename(basename) {\n  assertNonEmpty(basename, 'basename')\n  assertPart(basename, 'basename')\n  this.path = p.join(this.dirname || '', basename)\n}\n\nfunction getExtname() {\n  return typeof this.path === 'string' ? p.extname(this.path) : undefined\n}\n\nfunction setExtname(extname) {\n  assertPart(extname, 'extname')\n  assertPath(this.path, 'extname')\n\n  if (extname) {\n    if (extname.charCodeAt(0) !== 46 /* `.` */) {\n      throw new Error('`extname` must start with `.`')\n    }\n\n    if (extname.indexOf('.', 1) > -1) {\n      throw new Error('`extname` cannot contain multiple dots')\n    }\n  }\n\n  this.path = p.join(this.dirname, this.stem + (extname || ''))\n}\n\nfunction getStem() {\n  return typeof this.path === 'string'\n    ? p.basename(this.path, this.extname)\n    : undefined\n}\n\nfunction setStem(stem) {\n  assertNonEmpty(stem, 'stem')\n  assertPart(stem, 'stem')\n  this.path = p.join(this.dirname || '', stem + (this.extname || ''))\n}\n\n// Get the value of the file.\nfunction toString(encoding) {\n  return (this.contents || '').toString(encoding)\n}\n\n// Assert that `part` is not a path (i.e., does not contain `p.sep`).\nfunction assertPart(part, name) {\n  if (part && part.indexOf(p.sep) > -1) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + p.sep + '`'\n    )\n  }\n}\n\n// Assert that `part` is not empty.\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n// Assert `path` exists.\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n","'use strict'\n\nvar VMessage = require('vfile-message')\nvar VFile = require('./core.js')\n\nmodule.exports = VFile\n\nVFile.prototype.message = message\nVFile.prototype.info = info\nVFile.prototype.fail = fail\n\n// Create a message with `reason` at `position`.\n// When an error is passed in as `reason`, copies the stack.\nfunction message(reason, position, origin) {\n  var message = new VMessage(reason, position, origin)\n\n  if (this.path) {\n    message.name = this.path + ':' + message.name\n    message.file = this.path\n  }\n\n  message.fatal = false\n\n  this.messages.push(message)\n\n  return message\n}\n\n// Fail: creates a vmessage, associates it with the file, and throws it.\nfunction fail() {\n  var message = this.message.apply(this, arguments)\n\n  message.fatal = true\n\n  throw message\n}\n\n// Info: creates a vmessage, associates it with the file, and marks the fatality\n// as null.\nfunction info() {\n  var message = this.message.apply(this, arguments)\n\n  message.fatal = null\n\n  return message\n}\n","'use strict'\n\nmodule.exports = require('path')\n","'use strict'\n\nmodule.exports = process\n","\n\"use strict\";\n\nvar path = require(\"path\"),\n  fs = require(\"fs\"),\n  minimist = require(\"minimist\"),\n  file = require(\"../lib/file\"),\n  transform = require(\"../lib/transform\"),\n  files;\n\nfunction cleanPath(path) {\n  var homeExpanded =\n    path.indexOf(\"~\") === 0 ? process.env.HOME + path.substr(1) : path;\n\n  // Escape all spaces\n  return homeExpanded.replace(/\\s/g, \"\\\\ \");\n}\n\nfunction transformAndSave(\n  files,\n  mode,\n  maxHeaderLevel,\n  title,\n  notitle,\n  entryPrefix,\n  processAll,\n  stdOut,\n  updateOnly\n) {\n  if (processAll) {\n    console.log(\n      \"--all flag is enabled. Including headers before the TOC location.\"\n    );\n  }\n\n  if (updateOnly) {\n    console.log(\n      \"--update-only flag is enabled. Only updating files that already have a TOC.\"\n    );\n  }\n\n  console.log(\"\\n==================\\n\");\n\n  var transformed = files.map(function (x) {\n    var content = fs.readFileSync(x.path, \"utf8\"),\n      result = transform(\n        content,\n        mode,\n        maxHeaderLevel,\n        title,\n        notitle,\n        entryPrefix,\n        processAll,\n        updateOnly\n      );\n    result.path = x.path;\n    return result;\n  });\n  var changed = transformed.filter(function (x) {\n      return x.transformed;\n    }),\n    unchanged = transformed.filter(function (x) {\n      return !x.transformed;\n    }),\n    toc = transformed.filter(function (x) {\n      return x.toc;\n    });\n\n  if (stdOut) {\n    toc.forEach(function (x) {\n      console.log(x.toc);\n    });\n  }\n\n  unchanged.forEach(function (x) {\n    console.log('\"%s\" is up to date', x.path);\n  });\n\n  changed.forEach(function (x) {\n    if (stdOut) {\n      console.log('==================\\n\\n\"%s\" should be updated', x.path);\n    } else {\n      console.log('\"%s\" will be updated', x.path);\n      fs.writeFileSync(x.path, x.data, \"utf8\");\n    }\n  });\n}\n\nfunction printUsageAndExit(isErr) {\n  var outputFunc = isErr ? console.error : console.info;\n\n  outputFunc(\n    \"Usage: doctoc [mode] [--entryprefix prefix] [--notitle | --title title] [--maxlevel level] [--all] [--update-only] <path> (where path is some path to a directory (e.g., .) or a file (e.g., README.md))\"\n  );\n  outputFunc(\"\\nAvailable modes are:\");\n  for (var key in modes) {\n    outputFunc(\"  --%s\\t%s\", key, modes[key]);\n  }\n  outputFunc(\"Defaults to '\" + mode + \"'.\");\n\n  process.exit(isErr ? 2 : 0);\n}\n\nvar modes = {\n  bitbucket: \"bitbucket.org\",\n  nodejs: \"nodejs.org\",\n  github: \"github.com\",\n  gitlab: \"gitlab.com\",\n  ghost: \"ghost.org\",\n};\n\nvar mode = modes[\"github\"];\n\nvar argv = minimist(process.argv.slice(2), {\n  boolean: [\n    \"h\",\n    \"help\",\n    \"T\",\n    \"notitle\",\n    \"s\",\n    \"stdout\",\n    \"all\",\n    \"u\",\n    \"update-only\",\n  ].concat(Object.keys(modes)),\n  string: [\"title\", \"t\", \"maxlevel\", \"m\", \"entryprefix\"],\n  unknown: function (a) {\n    return a[0] == \"-\"\n      ? (console.error(\"Unknown option(s): \" + a), printUsageAndExit(true))\n      : true;\n  },\n});\n\nif (argv.h || argv.help) {\n  printUsageAndExit();\n}\n\nfor (var key in modes) {\n  if (argv[key]) {\n    mode = modes[key];\n  }\n}\n\nvar title = argv.t || argv.title;\nvar notitle = argv.T || argv.notitle;\nvar entryPrefix = argv.entryprefix || \"-\";\nvar processAll = argv.all;\nvar stdOut = argv.s || argv.stdout;\nvar updateOnly = argv.u || argv[\"update-only\"];\n\nvar maxHeaderLevel = argv.m || argv.maxlevel;\nif ((maxHeaderLevel && isNaN(maxHe
¬© 2017 azu\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ASTNodeTypes = void 0;\nvar ASTNodeTypes;\n(function (ASTNodeTypes) {\n    ASTNodeTypes[\"Document\"] = \"Document\";\n    ASTNodeTypes[\"DocumentExit\"] = \"Document:exit\";\n    ASTNodeTypes[\"Paragraph\"] = \"Paragraph\";\n    ASTNodeTypes[\"ParagraphExit\"] = \"Paragraph:exit\";\n    ASTNodeTypes[\"BlockQuote\"] = \"BlockQuote\";\n    ASTNodeTypes[\"BlockQuoteExit\"] = \"BlockQuote:exit\";\n    ASTNodeTypes[\"ListItem\"] = \"ListItem\";\n    ASTNodeTypes[\"ListItemExit\"] = \"ListItem:exit\";\n    ASTNodeTypes[\"List\"] = \"List\";\n    ASTNodeTypes[\"ListExit\"] = \"List:exit\";\n    ASTNodeTypes[\"Header\"] = \"Header\";\n    ASTNodeTypes[\"HeaderExit\"] = \"Header:exit\";\n    ASTNodeTypes[\"CodeBlock\"] = \"CodeBlock\";\n    ASTNodeTypes[\"CodeBlockExit\"] = \"CodeBlock:exit\";\n    ASTNodeTypes[\"HtmlBlock\"] = \"HtmlBlock\";\n    ASTNodeTypes[\"HtmlBlockExit\"] = \"HtmlBlock:exit\";\n    ASTNodeTypes[\"HorizontalRule\"] = \"HorizontalRule\";\n    ASTNodeTypes[\"HorizontalRuleExit\"] = \"HorizontalRule:exit\";\n    ASTNodeTypes[\"Comment\"] = \"Comment\";\n    ASTNodeTypes[\"CommentExit\"] = \"Comment:exit\";\n    /**\n     * @deprecated\n     */\n    ASTNodeTypes[\"ReferenceDef\"] = \"ReferenceDef\";\n    /**\n     * @deprecated\n     */\n    ASTNodeTypes[\"ReferenceDefExit\"] = \"ReferenceDef:exit\";\n    // inline\n    ASTNodeTypes[\"Str\"] = \"Str\";\n    ASTNodeTypes[\"StrExit\"] = \"Str:exit\";\n    ASTNodeTypes[\"Break\"] = \"Break\";\n    ASTNodeTypes[\"BreakExit\"] = \"Break:exit\";\n    ASTNodeTypes[\"Emphasis\"] = \"Emphasis\";\n    ASTNodeTypes[\"EmphasisExit\"] = \"Emphasis:exit\";\n    ASTNodeTypes[\"Strong\"] = \"Strong\";\n    ASTNodeTypes[\"StrongExit\"] = \"Strong:exit\";\n    ASTNodeTypes[\"Html\"] = \"Html\";\n    ASTNodeTypes[\"HtmlExit\"] = \"Html:exit\";\n    ASTNodeTypes[\"Link\"] = \"Link\";\n    ASTNodeTypes[\"LinkExit\"] = \"Link:exit\";\n    ASTNodeTypes[\"Image\"] = \"Image\";\n    ASTNodeTypes[\"ImageExit\"] = \"Image:exit\";\n    ASTNodeTypes[\"Code\"] = \"Code\";\n    ASTNodeTypes[\"CodeExit\"] = \"Code:exit\";\n    ASTNodeTypes[\"Delete\"] = \"Delete\";\n    ASTNodeTypes[\"DeleteExit\"] = \"Delete:exit\";\n})(ASTNodeTypes = exports.ASTNodeTypes || (exports.ASTNodeTypes = {}));\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = exports.Syntax = void 0;\nconst markdown_syntax_map_1 = require(\"./mapping/markdown-syntax-map\");\nconst ast_node_types_1 = require(\"@textlint/ast-node-types\");\nObject.defineProperty(exports, \"Syntax\", { enumerable: true, get: function () { return ast_node_types_1.ASTNodeTypes; } });\nconst traverse_1 = __importDefault(require(\"traverse\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst parse_markdown_1 = require(\"./parse-markdown\");\nconst debug = (0, debug_1.default)(\"@textlint/markdown-to-ast\");\n/**\n * parse markdown text and return ast mapped location info.\n * @param {string} text\n * @returns {TxtNode}\n */\nfunction parse(text) {\n    // remark-parse's AST does not consider BOM\n    // AST's position does not +1 by BOM\n    // So, just trim BOM and parse it for `raw` property\n    // textlint's SourceCode also take same approach - trim BOM and check the position\n    // This means that the loading side need to consider BOM position - for example fs.readFile and text slice script.\n    // https://github.com/micromark/micromark/blob/0f19c1ac25964872a160d8b536878b125ddfe393/lib/preprocess.mjs#L29-L31\n    const hasBOM = text.charCodeAt(0) === 0xfeff;\n    const textWithoutBOM = hasBOM ? text.slice(1) : text;\n    const ast = (0, parse_markdown_1.parseMarkdown)(textWithoutBOM);\n    (0, traverse_1.default)(ast).forEach(function (node) {\n        // eslint-disable-next-line no-invalid-this\n        if (this.notLeaf) {\n            if (node.type) {\n                const replacedType = markdown_syntax_map_1.SyntaxMap[node.type];\n                if (!replacedType) {\n                    debug(`replacedType : ${replacedType} , node.type: ${node.type}`);\n                }\n                else {\n                    node.type = replacedType;\n                }\n            }\n            // map `range`, `loc` and `raw` to node\n            if (node.position) {\n                const position = node.position;\n                const positionCompensated = {\n                    start: { line: position.start.line, column: Math.max(position.start.column - 1, 0) },\n                    end: { line: position.end.line, column: Math.max(position.end.column - 1, 0) }\n                };\n                const range = [position.start.offset, position.end.offset];\n                node.loc = positionCompensated;\n                node.range = range;\n                node.raw = textWithoutBOM.slice(range[0], range[1]);\n                // Compatible for https://github.com/syntax-tree/unist, but it is hidden\n                Object.defineProperty(node, \"position\", {\n                    enumerable: false,\n                    configurable: false,\n                    writable: false,\n                    value: position\n                });\n            }\n        }\n    });\n    return ast;\n}\nexports.parse = parse;\n//# sourceMappingURL=index.js.map","// LICENSE : MIT\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyntaxMap = void 0;\nconst ast_node_types_1 = require(\"@textlint/ast-node-types\");\nexports.SyntaxMap = {\n    root: ast_node_types_1.ASTNodeTypes.Document,\n    paragraph: ast_node_types_1.ASTNodeTypes.Paragraph,\n    blockquote: ast_node_types_1.ASTNodeTypes.BlockQuote,\n    listItem: ast_node_types_1.ASTNodeTypes.ListItem,\n    list: ast_node_types_1.ASTNodeTypes.List,\n    Bullet: \"Bullet\",\n    heading: ast_node_types_1.ASTNodeTypes.Header,\n    code: ast_node_types_1.ASTNodeTypes.CodeBlock,\n    HtmlBlock: ast_node_types_1.ASTNodeTypes.HtmlBlock,\n    thematicBreak: ast_node_types_1.ASTNodeTypes.HorizontalRule,\n    // inline block\n    text: ast_node_types_1.ASTNodeTypes.Str,\n    break: ast_node_types_1.ASTNodeTypes.Break,\n    emphasis: ast_node_types_1.ASTNodeTypes.Emphasis,\n    strong: ast_node_types_1.ASTNodeTypes.Strong,\n    html: ast_node_types_1.ASTNodeTypes.Html,\n    link: ast_node_types_1.ASTNodeTypes.Link,\n    image: ast_node_types_1.ASTNodeTypes.Image,\n    inlineCode: ast_node_types_1.ASTNodeTypes.Code,\n    delete: ast_node_types_1.ASTNodeTypes.Delete,\n    // remark(markdown) extension\n    // Following type is not in @textlint/ast-node-types\n    yaml: \"Yaml\",\n    table: \"Table\",\n    tableRow: \"TableRow\",\n    tableCell: \"TableCell\",\n    linkReference: \"LinkReference\",\n    imageReference: \"ImageReference\",\n    footnoteReference: \"FootnoteReference\",\n    definition: \"Definition\",\n    /**\n     * @deprecated\n     */\n    ReferenceDef: ast_node_types_1.ASTNodeTypes.ReferenceDef\n};\n//# sourceMappingURL=markdown-syntax-map.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseMarkdown = void 0;\nconst unified_1 = __importDefault(require(\"unified\"));\n// @ts-ignore\nconst from_markdown_1 = __importDefault(require(\"mdast-util-gfm-autolink-literal/from-markdown\"));\n// FIXME: Disable auto link literal transforms that break AST node\n// https://github.com/remarkjs/remark-gfm/issues/16\n// Need to override before import gfm plugin\nfrom_markdown_1.default.transforms = [];\n// Load plugins\nconst remark_gfm_1 = __importDefault(require(\"remark-gfm\"));\nconst remark_parse_1 = __importDefault(require(\"remark-parse\"));\nconst remark_frontmatter_1 = __importDefault(require(\"remark-frontmatter\"));\nconst remark_footnotes_1 = __importDefault(require(\"remark-footnotes\"));\nconst remark = (0, unified_1.default)().use(remark_parse_1.default).use(remark_frontmatter_1.default, [\"yaml\"]).use(remark_gfm_1.default).use(remark_footnotes_1.default, {\n    inlineNotes: true\n});\nconst parseMarkdown = (text) => {\n    return remark.parse(text);\n};\nexports.parseMarkdown = parseMarkdown;\n//# sourceMappingURL=parse-markdown.js.map","'use strict';\n\nvar emojiRegex = require('emoji-regex');\nvar removeMd = require('remove-markdown');\n\n// https://github.com/joyent/node/blob/192192a09e2d2e0d6bdd0934f602d2dbbf10ed06/tools/doc/html.js#L172-L183\nfunction getNodejsId(text, repetition) {\n  text = text.replace(/[^a-z0-9]+/g, '_');\n  text = text.replace(/^_+|_+$/, '');\n  text = text.replace(/^([^a-z])/, '_$1');\n\n  // If no repetition, or if the repetition is 0 then ignore. Otherwise append '_' and the number.\n  // An example may be found here: http://nodejs.org/api/domain.html#domain_example_1\n  if (repetition) {\n    text += '_' + repetition;\n  }\n\n  return text;\n}\n\nfunction basicGithubId(text) {\n  retur
¬© `, and `\\+` does not match `+`.\n// But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n// matches `a b`.\n// So, we do prefer the label when figuring out how we‚Äôre going to serialize:\n// it has whitespace, casing, and we can ignore most useless character escapes\n// and all character references.\nfunction association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return node.identifier\n    .replace(characterEscape, '$1')\n    .replace(characterReference, decodeIfPossible)\n}\n\nfunction decodeIfPossible($0, $1) {\n  return decode($1) || $0\n}\n","module.exports = checkBullet\n\nfunction checkBullet(context) {\n  var marker = context.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","module.exports = checkListItemIndent\n\nfunction checkListItemIndent(context) {\n  var style = context.options.listItemIndent || 'tab'\n\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","module.exports = flow\n\nvar repeat = require('repeat-string')\n\nfunction flow(parent, context) {\n  var children = parent.children || []\n  var results = []\n  var index = -1\n  var child\n\n  while (++index < children.length) {\n    child = children[index]\n\n    results.push(\n      context.handle(child, parent, context, {before: '\\n', after: '\\n'})\n    )\n\n    if (index + 1 < children.length) {\n      results.push(between(child, children[index + 1]))\n    }\n  }\n\n  return results.join('')\n\n  function between(left, right) {\n    var index = -1\n    var result\n\n    while (++index < context.join.length) {\n      result = context.join[index](left, right, parent, context)\n\n      if (result === true || result === 1) {\n        break\n      }\n\n      if (typeof result === 'number') {\n        return repeat('\\n', 1 + Number(result))\n      }\n\n      if (result === false) {\n        return '\\n\\n<!---->\\n\\n'\n      }\n    }\n\n    return '\\n\\n'\n  }\n}\n","module.exports = phrasing\n\nfunction phrasing(parent, context, safeOptions) {\n  var children = parent.children || []\n  var results = []\n  var index = -1\n  var before = safeOptions.before\n  var after\n  var handle\n  var child\n\n  while (++index < children.length) {\n    child = children[index]\n\n    if (index + 1 < children.length) {\n      handle = context.handle.handlers[children[index + 1].type]\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, context, {\n            before: '',\n            after: ''\n          }).charAt(0)\n        : ''\n    } else {\n      after = safeOptions.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we‚Äôd serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can‚Äôt escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n    }\n\n    results.push(\n      context.handle(child, parent, context, {\n        before: before,\n        after: after\n      })\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  return results.join('')\n}\n","module.exports = indentLines\n\nvar eol = /\\r?\\n|\\r/g\n\nfunction indentLines(value, map) {\n  var result = []\n  var start = 0\n  var line = 0\n  var match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","module.exports = patternCompile\n\nfunction patternCompile(pattern) {\n  var before\n  var after\n\n  if (!pattern._compiled) {\n    before = pattern.before ? '(?:' + pattern.before + ')' : ''\n    after = pattern.after ? '(?:' + pattern.after + ')' : ''\n\n    if (pattern.atBreak) {\n      before = '[\\\\r\\\\n][\\\\t ]*' + before\n    }\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (after || ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","module.exports = patternInScope\n\nfunction patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct)\n  )\n}\n\nfunction listInScope(stack, list, none) {\n  var index\n\n  if (!list) {\n    return none\n  }\n\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  index = -1\n\n  while (++index < list.length) {\n    if (stack.indexOf(list[index]) !== -1) {\n      return true\n    }\n  }\n\n  return false\n}\n","module.exports = safe\n\nvar patternCompile = require('./pattern-compile')\nvar patternInScope = require('./pattern-in-scope')\n\nfunction safe(context, input, config) {\n  var value = (config.before || '') + (input || '') + (config.after || '')\n  var positions = []\n  var result = []\n  var infos = {}\n  var index = -1\n  var before\n  var after\n  var position\n  var pattern\n  var expression\n  var match\n  var start\n  var end\n\n  while (++index < context.unsafe.length) {\n    pattern = context.unsafe[index]\n\n    if (!patternInScope(context.stack, pattern)) {\n      continue\n    }\n\n    expression = patternCompile(pattern)\n\n    while ((match = expression.exec(value))) {\n      before = 'before' in pattern || pattern.atBreak\n      after = 'after' in pattern\n\n      position = match.index + (before ? match[1].length : 0)\n\n      if (positions.indexOf(position) === -1) {\n        positions.push(position)\n        infos[position] = {before: before, after: after}\n      } else {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  start = config.before ? config.before.length : 0\n  end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    position = positions[index]\n\n    if (\n      // Character before or after matched:\n      position < start ||\n      position >= end\n    ) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      position + 1 < end &&\n      positions[index + 1] === position + 1 &&\n      infos[position].after &&\n      !infos[position + 1].before &&\n      !infos[position + 1].after\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || config.encode.indexOf(value.charAt(position)) === -1)\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\nfunction numerical(a, b) {\n  return a - b\n}\n\nfunction escapeBackslashes(value, after) {\n  var expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  var positions = []\n  var results = []\n  var index = -1\n  var start = 0\n  var whole = value + after\n  var match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","'use strict'\n\nmodule.exports = toString\n\n// Get the text content of a node.\n// Prefer the node‚Äôs plain-text fields, otherwise serialize its children,\n// and if the given value is an array, serialize the nodes in it.\nfunction toString(node) {\n  return (\n    (node &&\n      (node.value ||\n        node.alt ||\n        node.title ||\n        ('children' in node && all(node.children)) ||\n        ('length' in node && all(node)))) ||\n    ''\n  )\n}\n\nfunction all(values) {\n  var result = []\n  var index = -1\n\n  while (++index < values.length) {\n    result[index] = toString(values[index])\n  }\n\n  return result.join('')\n}\n","module.exports = footnote\n\nvar normalizeIdentifier = require('micromark/dist/util/normalize-identifier')\nvar blank = require('micromark/dist/tokenize/partial-blank-line')\nvar createSpace = require('micromark/dist/tokenize/factory-space')\nvar chunkedSplice = require('micromark/dist/util/chunked-splice')\nvar prefixSize = require('micromark/dist/util/prefix-size')\nvar shallow = require('micromark/dist/util/shallow')\nvar resolveAll = require('micromark/dist/util/resolve-all')\n\nvar indent = {tokenize: tokenizeIndent, partial: true}\n\nfunction footnote(options) {\n  var settings = options || {}\n  var call = {tokenize: tokenizeFootnoteCall}\n  var noteStart = {tokenize: tokenizeNoteStart, resolveAll: resolveAllNote}\n  var noteEnd = {\n    add: 'after',\n    tokenize: tokenizeNoteEnd,\n    resolveAll: resolveAllNote,\n    resolveTo: resolveToNoteEnd\n  }\n  var definition = {\n    tokenize: tokenizeDefinitionStart,\n    continuation: {tokenize: tokenizeDefinitionContinuation},\n    exit: footnoteDefinitionEnd\n  }\n  var text = {91: call}\n\n  if (settings.inlineNotes) {\n    text[93] = noteEnd\n    text[94] = noteStart\n  }\n\n  return {\n    _hiddenFootnoteSupport: {},\n    document: {91: definition},\n    text: text\n  }\n}\n\n// Remove remaining note starts.\nfunction resolveAllNote(events) {\n  var length = events.length\n  var index = -1\n  var token\n\n  while (++index < length) {\n    token = events[index][1]\n\n    if (events[index][0] === 'enter' && token.type === 'inlineNoteStart') {\n      token.type = 'data'\n      // Remove the two marker (`^[`).\n      events.splice(index + 1, 4)\n      length -= 4\n    }\n  }\n\n  return events\n}\n\nfunction resolveToNoteEnd(events, context) {\n  var index = events.length - 4\n  var group\n  var text\n  var token\n  var type\n  var openIndex\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n\n    // Find where the note starts.\n    if (events[index][0] === 'enter' && token.type === 'inlineNoteStart') {\n      openIndex = index\n      type = 'inlineNote'\n      break\n    }\n  }\n\n  group = {\n    type: type,\n    start: shallow(events[openIndex][1].start),\n    end: shallow(events[events.length - 1][1].end)\n  }\n\n  text = {\n    type: 'inlineNoteText',\n    start: shallow(events[openIndex + 4][1].end),\n    end: shallow(events[events.length - 3][1].start)\n  }\n\n  var note = [\n    ['enter', group, context],\n    events[openIndex + 1],\n    events[openIndex + 2],\n    events[openIndex + 3],\n    events[openIndex + 4],\n    ['enter', text, context]\n  ]\n\n  chunkedSplice(\n    note,\n    note.length,\n    0,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(openIndex + 6, -4),\n      context\n    )\n  )\n\n  note.push(\n    ['exit', text, context],\n    events[events.length - 2],\n    events[events.length - 3],\n    ['exit', group, context]\n  )\n\n  chunkedSplice(events, index, events.length - index, note)\n\n  return events\n}\n\nfunction tokenizeFootnoteCall(effects, ok, nok) {\n  var self = this\n  var defined = self.parser.footnotes || (self.parser.footnotes = [])\n  var size = 0\n  var data\n\n  return start\n\n  function start(code) {\n    // istanbul ignore next - Hooks.\n    if (code !== 91) return nok(code)\n\n    effects.enter('footnoteCall')\n    effects.enter('footnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('footnoteCallLabelMarker')\n    return callStart\n  }\n\n  function callStart(code) {\n    if (code !== 94) return nok(code)\n\n    effects.enter('footnoteCallMarker')\n    effects.consume(code)\n    effects.exit('footnoteCallMarker')\n    effects.enter('footnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n\n  function callData(code) {\n    var token\n\n    if (code === null || code === 91 || size++ > 999) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code)\n      }\n\n      effects.exit('chunkString')\n      token = effects.exit('footnoteCallString')\n      return defined.indexOf(normalizeIdentifier(self.sliceSerialize(token))) <\n        0\n        ? nok(code)\n        : end(code)\n    }\n\n    effects.consume(code)\n\n    if (!(code < 0 || code === 32)) {\n      data = true\n    }\n\n    return code === 92 ? callEscape : callData\n  }\n\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n\n    return callData(code)\n  }\n\n  function end(code) {\n    // Always a `]`.\n    effects.enter('footnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('footnoteCallLabelMarker')\n    effects.exit('footnoteCall')\n    return ok\n  }\n}\n\nfunction tokenizeNoteStart(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    // istanbul ignore next - Hooks.\n    if (code !== 94) return nok(code)\n\n    effects.enter('inlineNoteStart')\n    effects.enter('inlineNoteMarker')\n    effects.consume(code)\n    effects.exit('inlineNoteMarker')\n    return noteStart\n  }\n\n  function noteStart(code) {\n    if (code !== 91) return nok(code)\n\n    effects.enter('inlineNoteStartMarker')\n    effects.consume(code)\n    effects.exit('inlineNoteStartMarker')\n    effects.exit('inlineNoteStart')\n    return ok\n  }\n}\n\nfunction tokenizeNoteEnd(effects, ok, nok) {\n  var self = this\n\n  return start\n\n  function start(code) {\n    var index = self.events.length\n    var hasStart\n\n    // Find an opening.\n    while (index--) {\n      if (self.events[index][1].type === 'inlineNoteStart') {\n        hasStart = true\n        break\n      }\n    }\n\n    // istanbul ignore next - Hooks.\n    if (code !== 93 || !hasStart) {\n      return nok(code)\n    }\n\n    effects.enter('inlineNoteEnd')\n    effects.enter('inlineNoteEndMarker')\n    effects.consume(code)\n    effects.exit('inlineNoteEndMarker')\n    effects.exit('inlineNoteEnd')\n    return ok\n  }\n}\n\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  var self = this\n  var defined = self.parser.footnotes || (self.parser.footnotes = [])\n  var identifier\n  var size = 0\n  var data\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore if - hooks. */\n    if (code !== 91) {\n      return nok(code)\n    }\n\n    effects.enter('footnoteDefinition')._container = true\n    effects.enter('footnoteDefinitionLabel')\n    effects.enter('footnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('footnoteDefinitionLabelMarker')\n    return labelStart\n  }\n\n  function labelStart(code) {\n    // `^`\n    if (code !== 94) return nok(code)\n\n    effects.enter('footnoteDefinitionMarker')\n    effects.consume(code)\n    effects.exit('footnoteDefinitionMarker')\n    effects.enter('footnoteDefinitionLabelString')\n    return atBreak\n  }\n\n  function atBreak(code) {\n    var token\n\n    if (code === null || code === 91 || size > 999) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code)\n      }\n\n      token = effects.exit('footnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('footnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('footnoteDefinitionLabelMarker')\n      effects.exit('footnoteDefinitionLabel')\n      return labelAfter\n    }\n\n    if (code === -5 || code === -4 || code === -3) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      size++\n      return atBreak\n    }\n\n    effects.enter('chunkString').contentType = 'string'\n    return label(code)\n  }\n\n  function label(code) {\n    if (\n      code === null ||\n      code === -5 ||\n      code === -4 ||\n      code === -3 ||\n      code === 91 ||\n      code === 93 ||\n      size > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n\n    if (!(code < 0 || code === 32)) {\n      data = true\n    }\n\n    size++\n    effects.consume(code)\n    return code === 92 ? labelEscape : label\n  }\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return label\n    }\n\n    return label(code)\n  }\n\n  function labelAfter(code) {\n    if (code !== 58) {\n      return nok(code)\n    }\n\n    effects.enter('definitionMarker')\n    effects.consume(code)\n    effects.exit('definitionMarker')\n    return effects.check(blank, onBlank, nonBlank)\n  }\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    return done(code)\n  }\n\n  function nonBlank(code) {\n    // A space or tab.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('footnoteDefinitionWhitespace')\n      effects.consume(code)\n      effects.exit('footnoteDefinitionWhitespace')\n      return done(code)\n    }\n\n    // No space is also fine, just like a block quote marker.\n    return done(code)\n  }\n\n  function done(code) {\n    if (defined.indexOf(identifier) < 0) {\n      defined.push(identifier)\n    }\n\n    return ok(code)\n  }\n}\n\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  var self = this\n\n  return effects.check(blank, onBlank, notBlank)\n\n  // Continued blank lines are fine.\n  function onBlank(code) {\n    if (self.containerState.initialBlankLine) {\n      self.containerState.furtherBlankLines = true\n    }\n\n    return ok(code)\n  }\n\n  // If there were continued blank lines, or this isn‚Äôt indented at all.\n  function notBlank(code) {\n    if (\n      self.containerState.furtherBlankLines ||\n      !(code === -2 || code === -1 || code === 32)\n    ) {\n      return nok(code)\n    }\n\n    self.containerState.initialBlankLine = undefined\n    self.containerState.furtherBlankLines = undefined\n    return effects.attempt(indent, ok, nok)(code)\n  }\n}\n\nfunction footnoteDefinitionEnd(effects) {\n  effects.exit('footnoteDefinition')\n}\n\nfunction tokenizeIndent(effects, ok, nok) {\n  var self = this\n\n  return createSpace(effects, afterPrefix, 'footnoteDefinitionIndent', 5)\n\n  function afterPrefix(code) {\n    return prefixSize(self.events, 'footnoteDefinitionIndent') === 4\n      ? ok(code)\n      : nok(code)\n  }\n}\n","module.exports = require('./lib/syntax')\n","module.exports = matters\n\nvar fault = require('fault')\n\nvar own = {}.hasOwnProperty\n\nvar markers = {yaml: '-', toml: '+'}\n\nfunction matters(options) {\n  var settings = options || 'yaml'\n  var results = []\n  var index = -1\n  var length\n\n  // One preset or matter.\n  if (typeof settings === 'string' || !('length' in settings)) {\n    settings = [settings]\n  }\n\n  length = settings.length\n\n  while (++index < length) {\n    results[index] = matter(settings[index])\n  }\n\n  return results\n}\n\nfunction matter(option) {\n  var result = option\n\n  if (typeof result === 'string') {\n    if (!own.call(markers, result)) {\n      throw fault('Missing matter definition for `%s`', result)\n    }\n\n    result = {type: result, marker: markers[result]}\n  } else if (typeof result !== 'object') {\n    throw fault('Expected matter to be an object, not `%j`', result)\n  }\n\n  if (!own.call(result, 'type')) {\n    throw fault('Missing `type` in matter `%j`', result)\n  }\n\n  if (!own.call(result, 'fence') && !own.call(result, 'marker')) {\n    throw fault('Missing `marker` or `fence` in matter `%j`', result)\n  }\n\n  return result\n}\n","module.exports = create\n\nvar matters = require('./matters')\n\nfunction create(options) {\n  var settings = matters(options)\n  var length = settings.length\n  var index = -1\n  var flow = {}\n  var matter\n  var code\n\n  while (++index < length) {\n    matter = settings[index]\n    code = fence(matter, 'open').charCodeAt(0)\n    if (code in flow) {\n      flow[code].push(parse(matter))\n    } else {\n      flow[code] = [parse(matter)]\n    }\n  }\n\n  return {flow: flow}\n}\n\nfunction parse(matter) {\n  var name = matter.type\n  var anywhere = matter.anywhere\n  var valueType = name + 'Value'\n  var fenceType = name + 'Fence'\n  var sequenceType = fenceType + 'Sequence'\n  var fenceConstruct = {tokenize: tokenizeFence, partial: true}\n  var buffer\n\n  return {tokenize: tokenizeFrontmatter, concrete: true}\n\n  function tokenizeFrontmatter(effects, ok, nok) {\n    var self = this\n\n    return start\n\n    function start(code) {\n      var position = self.now()\n\n      if (position.column !== 1 || (!anywhere && position.line !== 1)) {\n        return nok(code)\n      }\n\n      effects.enter(name)\n      buffer = fence(matter, 'open')\n      return effects.attempt(fenceConstruct, afterOpeningFence, nok)(code)\n    }\n\n    function afterOpeningFence(code) {\n      buffer = fence(matter, 'close')\n      return lineEnd(code)\n    }\n\n    function lineStart(code) {\n      if (code === -5 || code === -4 || code === -3 || code === null) {\n        return lineEnd(code)\n      }\n\n      effects.enter(valueType)\n      return lineData(code)\n    }\n\n    function lineData(code) {\n      if (code === -5 || code === -4 || code === -3 || code === null) {\n        effects.exit(valueType)\n        return lineEnd(code)\n      }\n\n      effects.consume(code)\n      return lineData\n    }\n\n    function lineEnd(code) {\n      // Require a closing fence.\n      if (code === null) {\n        return nok(code)\n      }\n\n      // Can only be an eol.\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return effects.attempt(fenceConstruct, after, lineStart)\n    }\n\n    function after(code) {\n      effects.exit(name)\n      return ok(code)\n    }\n  }\n\n  function tokenizeFence(effects, ok, nok) {\n    var bufferIndex = 0\n\n    return start\n\n    function start(code) {\n      if (code === buffer.charCodeAt(bufferIndex)) {\n        effects.enter(fenceType)\n        effects.enter(sequenceType)\n        return insideSequence(code)\n      }\n\n      return nok(code)\n    }\n\n    function insideSequence(code) {\n      if (bufferIndex === buffer.length) {\n        effects.exit(sequenceType)\n\n        if (code === -2 || code === -1 || code === 32) {\n          effects.enter('whitespace')\n          return insideWhitespace(code)\n        }\n\n        return fenceEnd(code)\n      }\n\n      if (code === buffer.charCodeAt(bufferIndex)) {\n        effects.consume(code)\n        bufferIndex++\n        return insideSequence\n      }\n\n      return nok(code)\n    }\n\n    function insideWhitespace(code) {\n      if (code === -2 || code === -1 || code === 32) {\n        effects.consume(code)\n        return insideWhitespace\n      }\n\n      effects.exit('whitespace')\n      return fenceEnd(code)\n    }\n\n    function fenceEnd(code) {\n      if (code === -5 || code === -4 || code === -3 || code === null) {\n        effects.exit(fenceType)\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\nfunction fence(matter, prop) {\n  var marker\n\n  if (matter.marker) {\n    marker = pick(matter.marker, prop)\n    return marker + marker + marker\n  }\n\n  return pick(matter.fence, prop)\n}\n\nfunction pick(schema, prop) {\n  return typeof schema === 'string' ? schema : schema[prop]\n}\n","module.exports = require('./syntax')\n","var asciiAlpha = require('micromark/dist/character/ascii-alpha')\nvar asciiAlphanumeric = require('micromark/dist/character/ascii-alphanumeric')\nvar asciiControl = require('micromark/dist/character/ascii-control')\nvar markdownLineEnding = require('micromark/dist/character/markdown-line-ending')\nvar unicodePunctuation = require('micromark/dist/character/unicode-punctuation')\nvar unicodeWhitespace = require('micromark/dist/character/unicode-whitespace')\n\nvar www = {tokenize: tokenizeWww, partial: true}\nvar domain = {tokenize: tokenizeDomain, partial: true}\nvar path = {tokenize: tokenizePath, partial: true}\nvar punctuation = {tokenize: tokenizePunctuation, partial: true}\nvar namedCharacterReference = {\n  tokenize: tokenizeNamedCharacterReference,\n  partial: true\n}\n\nvar wwwAutolink = {tokenize: tokenizeWwwAutolink, previous: previousWww}\nvar httpAutolink = {tokenize: tokenizeHttpAutolink, previous: previousHttp}\nvar emailAutolink = {tokenize: tokenizeEmailAutolink, previous: previousEmail}\n\nvar text = {}\n\n// Export hooked constructs.\nexports.text = text\n\n// `0`\nvar code = 48\n\n// While the code is smaller than `{`.\nwhile (code < 123) {\n  text[code] = emailAutolink\n  code++\n  // Jump from `:` -> `A`\n  if (code === 58) code = 65\n  // Jump from `[` -> `a`\n  else if (code === 91) code = 97\n}\n\n// `+`\ntext[43] = emailAutolink\n// `-`\ntext[45] = emailAutolink\n// `.`\ntext[46] = emailAutolink\n// `_`\ntext[95] = emailAutolink\n// `h`.\ntext[72] = [emailAutolink, httpAutolink]\ntext[104] = [emailAutolink, httpAutolink]\n// `w`.\ntext[87] = [emailAutolink, wwwAutolink]\ntext[119] = [emailAutolink, wwwAutolink]\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  var self = this\n  var hasDot\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore next - hooks. */\n    if (\n      !gfmAtext(code) ||\n      !previousEmail(self.previous) ||\n      previous(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n\n    // `@`\n    if (code === 64) {\n      effects.consume(code)\n      return label\n    }\n\n    return nok(code)\n  }\n\n  function label(code) {\n    // `.`\n    if (code === 46) {\n      return effects.check(punctuation, done, dotContinuation)(code)\n    }\n\n    if (\n      // `-`\n      code === 45 ||\n      // `_`\n      code === 95\n    ) {\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code)\n    }\n\n    if (asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return label\n    }\n\n    return done(code)\n  }\n\n  function dotContinuation(code) {\n    effects.consume(code)\n    hasDot = true\n    return label\n  }\n\n  function dashOrUnderscoreContinuation(code) {\n    effects.consume(code)\n    return afterDashOrUnderscore\n  }\n\n  function afterDashOrUnderscore(code) {\n    // `.`\n    if (code === 46) {\n      return effects.check(punctuation, nok, dotContinuation)(code)\n    }\n\n    return label(code)\n  }\n\n  function done(code) {\n    if (hasDot) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  var self = this\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore next - hooks. */\n    if (\n      (code !== 87 && code - 32 !== 87) ||\n      !previousWww(self.previous) ||\n      previous(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww')\n    // For `www.` we check instead of attempt, because when it matches, GH\n    // treats it as part of a domain (yes, it says a valid domain must come\n    // after `www.`, but that‚Äôs not how it‚Äôs implemented by them).\n    return effects.check(\n      www,\n      effects.attempt(domain, effects.attempt(path, done), nok),\n      nok\n    )(code)\n  }\n\n  function done(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\nfunction tokenizeHttpAutolink(effects, ok, nok) {\n  var self = this\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore next - hooks. */\n    if (\n      (code !== 72 && code - 32 !== 72) ||\n      !previousHttp(self.previous) ||\n      previous(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkHttp')\n    effects.consume(code)\n    return t1\n  }\n\n  function t1(code) {\n    // `t`\n    if (code === 84 || code - 32 === 84) {\n      effects.consume(code)\n      return t2\n    }\n\n    return nok(code)\n  }\n\n  function t2(code) {\n    // `t`\n    if (code === 84 || code - 32 === 84) {\n      effects.consume(code)\n      return p\n    }\n\n    return nok(code)\n  }\n\n  function p(code) {\n    // `p`\n    if (code === 80 || code - 32 === 80) {\n      effects.consume(code)\n      return s\n    }\n\n    return nok(code)\n  }\n\n  function s(code) {\n    // `s`\n    if (code === 83 || code - 32 === 83) {\n      effects.consume(code)\n      return colon\n    }\n\n    return colon(code)\n  }\n\n  function colon(code) {\n    // `:`\n    if (code === 58) {\n      effects.consume(code)\n      return slash1\n    }\n\n    return nok(code)\n  }\n\n  function slash1(code) {\n    // `/`\n    if (code === 47) {\n      effects.consume(code)\n      return slash2\n    }\n\n    return nok(code)\n  }\n\n  function slash2(code) {\n    // `/`\n    if (code === 47) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    return asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, done), nok)(code)\n  }\n\n  function done(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\nfunction tokenizeWww(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    // Assume a `w`.\n    effects.consume(code)\n    return w2\n  }\n\n  function w2(code) {\n    // `w`\n    if (code === 87 || code - 32 === 87) {\n      effects.consume(code)\n      return w3\n    }\n\n    return nok(code)\n  }\n\n  function w3(code) {\n    // `w`\n    if (code === 87 || code - 32 === 87) {\n      effects.consume(code)\n      return dot\n    }\n\n    return nok(code)\n  }\n\n  function dot(code) {\n    // `.`\n    if (code === 46) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? nok(code) : ok(code)\n  }\n}\n\nfunction tokenizeDomain(effects, ok, nok) {\n  var hasUnderscoreInLastSegment\n  var hasUnderscoreInLastLastSegment\n\n  return domain\n\n  function domain(code) {\n    // `&`\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        done,\n        punctuationContinuation\n      )(code)\n    }\n\n    if (code === 46 /* `.` */ || code === 95 /* `_` */) {\n      return effects.check(punctuation, done, punctuationContinuation)(code)\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.ÈªûÁúã.com`,\n    // so that‚Äôs Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    if (\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      (code !== 45 /* `-` */ && unicodePunctuation(code))\n    ) {\n      return done(code)\n    }\n\n    effects.consume(code)\n    return domain\n  }\n\n  function punctuationContinuation(code) {\n    // `.`\n    if (code === 46) {\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment\n      hasUnderscoreInLastSegment = undefined\n      effects.consume(code)\n      return domain\n    }\n\n    // `_`\n    if (code === 95) hasUnderscoreInLastSegment = true\n\n    effects.consume(code)\n    return domain\n  }\n\n  function done(code) {\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizePath(effects, ok) {\n  var balance = 0\n\n  return inPath\n\n  function inPath(code) {\n    // `&`\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        ok,\n        continuedPunctuation\n      )(code)\n    }\n\n    // `(`\n    if (code === 40) {\n      balance++\n    }\n\n    // `)`\n    if (code === 41) {\n      return effects.check(\n        punctuation,\n        parenAtPathEnd,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (pathEnd(code)) {\n      return ok(code)\n    }\n\n    if (trailingPunctuation(code)) {\n      return effects.check(punctuation, ok, continuedPunctuation)(code)\n    }\n\n    effects.consume(code)\n    return inPath\n  }\n\n  function continuedPunctuation(code) {\n    effects.consume(code)\n    return inPath\n  }\n\n  function parenAtPathEnd(code) {\n    balance--\n    return balance < 0 ? ok(code) : continuedPunctuation(code)\n  }\n}\n\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    // Assume an ampersand.\n    effects.consume(code)\n    return inside\n  }\n\n  function inside(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return inside\n    }\n\n    // `;`\n    if (code === 59) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    // If the named character reference is followed by the end of the path, it‚Äôs\n    // not continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n\nfunction tokenizePunctuation(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    // Always a valid trailing punctuation marker.\n    effects.consume(code)\n    return after\n  }\n\n  function after(code) {\n    // Check the next.\n    if (trailingPunctuation(code)) {\n      effects.consume(code)\n      return after\n    }\n\n    // If the punctuation marker is followed by the end of the path, it‚Äôs not\n    // continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n\nfunction trailingPunctuation(code) {\n  return (\n    // `!`\n    code === 33 ||\n    // `\"`\n    code === 34 ||\n    // `'`\n    code === 39 ||\n    // `)`\n    code === 41 ||\n    // `*`\n    code === 42 ||\n    // `,`\n    code === 44 ||\n    // `.`\n    code === 46 ||\n    // `:`\n    code === 58 ||\n    // `;`\n    code === 59 ||\n    // `<`\n    code === 60 ||\n    // `?`\n    code === 63 ||\n    // `_`.\n    code === 95 ||\n    // `~`\n    code === 126\n  )\n}\n\nfunction pathEnd(code) {\n  return (\n    // EOF.\n    code === null ||\n    // CR, LF, CRLF, HT, VS.\n    code < 0 ||\n    // Space.\n    code === 32 ||\n    // `<`\n    code === 60\n  )\n}\n\nfunction gfmAtext(code) {\n  return (\n    code === 43 /* `+` */ ||\n    code === 45 /* `-` */ ||\n    code === 46 /* `.` */ ||\n    code === 95 /* `_` */ ||\n    asciiAlphanumeric(code)\n  )\n}\n\nfunction previousWww(code) {\n  return (\n    code === null ||\n    code < 0 ||\n    code === 32 /* ` ` */ ||\n    code === 40 /* `(` */ ||\n    code === 42 /* `*` */ ||\n    code === 95 /* `_` */ ||\n    code === 126 /* `~` */\n  )\n}\n\nfunction previousHttp(code) {\n  return code === null || !asciiAlpha(code)\n}\n\nfunction previousEmail(code) {\n  return code !== 47 /* `/` */ && previousHttp(code)\n}\n\nfunction previous(events) {\n  var index = events.length\n\n  while (index--) {\n    if (\n      (events[index][1].type === 'labelLink' ||\n        events[index][1].type === 'labelImage') &&\n      !events[index][1]._balanced\n    ) {\n      return true\n    }\n  }\n}\n","module.exports = create\n\nvar classifyCharacter = require('micromark/dist/util/classify-character')\nvar chunkedSplice = require('micromark/dist/util/chunked-splice')\nvar resolveAll = require('micromark/dist/util/resolve-all')\nvar shallow = require('micromark/dist/util/shallow')\n\nfunction create(options) {\n  var settings = options || {}\n  var single = settings.singleTilde\n  var tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {text: {126: tokenizer}, insideSpan: {null: tokenizer}}\n\n  // Take events and resolve strikethrough.\n  function resolveAllStrikethrough(events, context) {\n    var index = -1\n    var strikethrough\n    var text\n    var open\n    var nextEvents\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            strikethrough = {\n              type: 'strikethrough',\n              start: shallow(events[open][1].start),\n              end: shallow(events[index][1].end)\n            }\n\n            text = {\n              type: 'strikethroughText',\n              start: shallow(events[open][1].end),\n              end: shallow(events[index][1].start)\n            }\n\n            // Opening.\n            nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n\n            // Between.\n            chunkedSplice(\n              nextEvents,\n              nextEvents.length,\n              0,\n              resolveAll(\n                context.parser.constructs.insideSpan.null,\n                events.slice(open + 1, index),\n                context\n              )\n            )\n\n            // Closing.\n            chunkedSplice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n\n            chunkedSplice(events, open - 1, index - open + 3, nextEvents)\n\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n\n    return removeRemainingSequences(events)\n  }\n\n  function removeRemainingSequences(events) {\n    var index = -1\n    var length = events.length\n\n    while (++index < length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n\n    return events\n  }\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    var previous = this.previous\n    var events = this.events\n    var size = 0\n\n    return start\n\n    function start(code) {\n      if (\n        code !== 126 ||\n        (previous === 126 &&\n          events[events.length - 1][1].type !== 'characterEscape')\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    function more(code) {\n      var before = classifyCharacter(previous)\n      var token\n      var after\n\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n\n      if (size < 2 && !single) return nok(code)\n      token = effects.exit('strikethroughSequenceTemporary')\n      after = classifyCharacter(code)\n      token._open = !after || (after === 2 && before)\n      token._close = !before || (before === 2 && after)\n      return ok(code)\n    }\n  }\n}\n","module.exports = require('./syntax')\n","exports.flow = {\n  null: {tokenize: tokenizeTable, resolve: resolveTable, interruptible: true}\n}\n\nvar createSpace = require('micromark/dist/tokenize/factory-space')\n\nvar setextUnderlineMini = {tokenize: tokenizeSetextUnderlineMini, partial: true}\nvar nextPrefixedOrBlank = {tokenize: tokenizeNextPrefixedOrBlank, partial: true}\n\nfunction resolveTable(events, context) {\n  var length = events.length\n  var index = -1\n  var token\n  var inHead\n  var inDelimiterRow\n  var inRow\n  var cell\n  var content\n  var text\n  var contentStart\n  var contentEnd\n  var cellStart\n\n  while (++index < length) {\n    token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          contentType: 'text'\n        }\n\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        length = events.length\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart &&\n      cellStart + 1 < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      length = events.length\n      cellStart = index + 1\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n\nfunction tokenizeTable(effects, ok, nok) {\n  var align = []\n  var tableHeaderCount = 0\n  var seenDelimiter\n  var hasDash\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore if - used to be passed in beta micromark versions. */\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return nok(code)\n    }\n\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent')\n    // Can‚Äôt be space or eols at the start of a construct, so we‚Äôre in a cell.\n    return inCellContentHead(code)\n  }\n\n  function cellDividerHead(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n\n  function cellBreakHead(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndHead(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n\n  function inWhitespaceHead(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    // `\\`\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n\n  function inCellContentEscapeHead(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    }\n\n    // Anything else.\n    return inCellContentHead(code)\n  }\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n\n    // If a setext heading, exit.\n    return effects.check(\n      setextUnderlineMini,\n      nok,\n      // Support an indent before the delimiter row.\n      createSpace(effects, rowStartDelimiter, 'linePrefix', 4)\n    )\n  }\n\n  function rowStartDelimiter(code) {\n    // If there‚Äôs another space, or we‚Äôre at the EOL/EOF, exit.\n    if (code === null || code < 0 || code === 32) {\n      return nok(code)\n    }\n\n    effects.enter('tableDelimiterRow')\n    return atDelimiterRowBreak(code)\n  }\n\n  function atDelimiterRowBreak(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push(null)\n      return inFillerDelimiter\n    }\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    }\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  function inWhitespaceDelimiter(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n\n  function inFillerDelimiter(code) {\n    // `-`\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n\n  function afterLeftAlignment(code) {\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    }\n\n    // Anything else is not ok.\n    return nok(code)\n  }\n\n  function afterRightAlignment(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `|`\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow')\n\n    // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code)\n  }\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n\n  function tableContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    // We checked that it‚Äôs not a prefixed or blank line, so we‚Äôre certain a\n    // body is coming, though it may be indented.\n    return createSpace(effects, bodyStart, 'linePrefix', 4)\n  }\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n\n  function rowStartBody(code) {\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent')\n    // Can‚Äôt be space or eols at the start of a construct, so we‚Äôre in a cell.\n    return inCellContentBody(code)\n  }\n\n  function cellDividerBody(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n\n  function cellBreakBody(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndBody(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n\n  function inWhitespaceBody(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    e</text>

FileName: ./.github/actions/doctoc/dist/licenses.txt
SPDXID: SPDXRef-3ddf9bbd2a7a3fb95164cf8d64a62b5d
FileChecksum: SHA1: c89732b0f3b5c368426a756a6a1af7b86cd98e30
LicenseConcluded: NOASSERTION
FileCopyrightText: <text>Copyright (C) 2009-2021 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
Copyright 2010 James Halliday (mail@substack.net)
Copyright 2010, 2011 Chris Winberry <chris@winberry.net>. All rights reserved.
Copyright 2013 Thorsten Lorenz.
Copyright (C) 2014 Stefan Thomas
Copyright (C) 2014 The cheeriojs contributors
Copyright (C) 2014 Titus Wormer <tituswormer@gmail.com>
Copyright (C) 2014-2016 Jon Schlinkert.
Copyright (C) 2014-2017 TJ Holowaychuk <tj@vision-media.ca>
Copyright (C) 2014-present azu
Copyright (C) 2015 Stian Gryt√∏yr
Copyright (C) 2015 Titus Wormer <mailto:tituswormer@gmail.com>
Copyright (C) 2015 Titus Wormer <tituswormer@gmail.com>
Copyright (C) 2015 azu
Copyright (C) 2016 Titus Wormer <tituswormer@gmail.com>
Copyright (C) 2017 Titus Wormer <tituswormer@gmail.com>
Copyright (C) 2018-2021 Josh Junon
Copyright (C) 2020 Titus Wormer <tituswormer@gmail.com>
Copyright (C) 2020 Vercel, Inc.
Copyright (C) Felix B√∂hm
Copyright (C) Feross Aboukhadijeh
Copyright Mathias Bynens <https://mathiasbynens.be/>
Copyright (C) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
Copyright (C) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)</text>

FileName: ./.github/actions/doctoc/dist/sourcemap-register.js
SPDXID: SPDXRef-4c850f738b1a8fcac63ec202d29f6db2
FileChecksum: SHA1: 2069f7d594fdb723068dbc6e606a79f454b0ca3a
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./.github/workflows/cyclonedx.yml
SPDXID: SPDXRef-be8ef011922b327da12cc035c3a83dc8
FileChecksum: SHA1: 6533f7d2ea067656895a029b0452201549ee539f
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./.github/workflows/repo-create_doctoc_md.yml
SPDXID: SPDXRef-21d8d67205da83e7440cfe9c8c7648e1
FileChecksum: SHA1: 8ab21f1b0c2091bd9b1ef2475963c4e9da4bab98
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./.gitignore
SPDXID: SPDXRef-196562bf309bf22c3b5cc9534552f334
FileChecksum: SHA1: 4d38d9df267562c702ccfe8fa52c4fff612576f3
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./CMakeLists.txt
SPDXID: SPDXRef-aac72e083b88222e3b23b6d409a7b58b
FileChecksum: SHA1: ec7b083def96bcf46cb5c964dd77b194b2246f23
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./README.md
SPDXID: SPDXRef-c9f12055ae2af043bb24f0e634511969
FileChecksum: SHA1: bbb1bfe6e60d2a306bb99878022b4c943a38a0ac
LicenseConcluded: NOASSERTION
FileCopyrightText: <text>¬© 2026 ZHENG Robert</text>

FileName: ./atom.zip
SPDXID: SPDXRef-16729123b828bff03aab5c26f66774b5
FileChecksum: SHA1: 077269afea3bc14ad5bff8731f0d248d5a2c4a8a
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./bin/atom
SPDXID: SPDXRef-125ea79a9c19f54fad42869e18300720
FileChecksum: SHA1: f488b967d0dd55e7c8b09b4dd97992117a0f5e42
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./bin/atom.bat
SPDXID: SPDXRef-b290eb21d89748a6e20b32a97dcfcc37
FileChecksum: SHA1: f1f62bfeb5867fa3f3bfbbcdb816825b40b3a214
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./configure/CMakeLists.txt
SPDXID: SPDXRef-4ba5edbb464648d726b957fd20f3c486
FileChecksum: SHA1: 5b5c77129b73a08e98c82b6bb99437183c06cd7a
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./configure/rz_config.hpp.in
SPDXID: SPDXRef-eff51a64ed7b15ae74591b405c14b213
FileChecksum: SHA1: 5e1c895aac5dd07548d54648ab430187627d669e
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2025 ZHENG Robert</text>

FileName: ./data/templates/de/mail.txt
SPDXID: SPDXRef-e31eb5869ce3b16f54ec5bbf06c7fc50
FileChecksum: SHA1: 740d26834f08d3a65023a504ebb49ed1cb3811d2
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./data/templates/email_template_de.html
SPDXID: SPDXRef-fa0d352fdf77444f3fff8d9581d879fe
FileChecksum: SHA1: 015c181d864b4d386d023fb7ef02e800f7592034
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./data/templates/email_template_en.html
SPDXID: SPDXRef-cb0a0a61c6464954a0c861bbc05cae06
FileChecksum: SHA1: 5b7b2073a5738e3960614507139dc63da1432031
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./data/templates/en/mail.txt
SPDXID: SPDXRef-a5dd71182f4dcfc0a1fe079af21104ef
FileChecksum: SHA1: 46862496a126165532cf5dcb8bf89e5e6852a404
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./include/controllers/home_controller.hpp
SPDXID: SPDXRef-57cf7d79fdc00f2ed6cf21a4ef5296cd
FileChecksum: SHA1: ff1bb8ca019a590932d672a9965f3ab7853602db
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./include/controllers/system_controller.hpp
SPDXID: SPDXRef-cdf5c6aa4a235aa53101b3f427393398
FileChecksum: SHA1: 803a58a56b97fb077bfaf30dbe32d22e69cf21e6
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./include/rz_config.hpp
SPDXID: SPDXRef-940635b69d00756c9f78f2f11a962770
FileChecksum: SHA1: 5eb07425d8b98f750bdd752f0d8e5dceeaa776be
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2025 ZHENG Robert</text>

FileName: ./include/services/database_service.hpp
SPDXID: SPDXRef-ca39c80dc0b0aa8865357c4980380929
FileChecksum: SHA1: 9a359e5730e6edc361981cf307031ea75a8c43dc
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./include/services/notification_service.hpp
SPDXID: SPDXRef-dc1d1dcce033c7869764cec192653a0e
FileChecksum: SHA1: e35a6597ca8eaa34aa49a65e8de8d1a4d400942d
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./include/services/smtp_service.hpp
SPDXID: SPDXRef-c58f4247b911dcec0cfff0e0fdd50cf5
FileChecksum: SHA1: cdd6d9da83b8e642111902674ea1e8db994580e6
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./include/utils/app_config.hpp
SPDXID: SPDXRef-0d2f0b069838ea40379c6ffa9c6e85c4
FileChecksum: SHA1: 509fdf771aa1597d6c99c109a5b56c8949204c34
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./lib/ca.mcgill.sable.jasmin-3.0.3.jar
SPDXID: SPDXRef-c73fda6c08061fea9234775e6b9069a4
FileChecksum: SHA1: bc29f7032c7ee8314d339e54ca809e351f88883a
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/ca.mcgill.sable.java_cup-0.9.2.jar
SPDXID: SPDXRef-3309c83063d02ec2a0df69757682adde
FileChecksum: SHA1: f36b758580fb9d472bfd5965aa9ac807fa66d242
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/ca.mcgill.sable.polyglot-2006.jar
SPDXID: SPDXRef-0316045d7f769c7ac6fa05473e3a8a1c
FileChecksum: SHA1: f0e528051faa260d83f53d58275954d973231ce7
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.github.javaparser.javaparser-core-3.27.1.jar
SPDXID: SPDXRef-83447446d2d86aab2197a1b8d46e1183
FileChecksum: SHA1: 62bb2609e872ba694c7b61aa005612dc886ec4c7
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.github.javaparser.javaparser-symbol-solver-core-3.27.1.jar
SPDXID: SPDXRef-8d7d6fdc42939dc9edd823740625d4fd
FileChecksum: SHA1: 8cbc20ac55fba1e49c1e22772023d7af4fa83acb
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.github.pathikrit.better-files_3-3.9.2.jar
SPDXID: SPDXRef-2ce89b14de2fec49cfe9d70aba00e138
FileChecksum: SHA1: 2a5101fe2dd386a1a3bffa5d7a210b1a2d646871
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.github.scopt.scopt_3-4.1.0.jar
SPDXID: SPDXRef-203df689a34d07eda55403469bfd4b68
FileChecksum: SHA1: 6e296ff09a2407bc3f74d3e62e76a384c07dbc8d
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.google.code.findbugs.jsr305-3.0.2.jar
SPDXID: SPDXRef-f57667474205937f35aafe6727907697
FileChecksum: SHA1: 25ea2e8b0c338a877313bd4672d3fe056ea78f0d
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.google.errorprone.error_prone_annotations-2.41.0.jar
SPDXID: SPDXRef-d2e6e642baa504faf5b8e085d26de629
FileChecksum: SHA1: 4381275efdef6ddfae38f002c31e84cd001c97f0
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.google.guava.failureaccess-1.0.3.jar
SPDXID: SPDXRef-d8fcb5d13b3800d8c65f750b4ab7177c
FileChecksum: SHA1: aeaffd00d57023a2c947393ed251f0354f0985fc
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.google.guava.guava-33.5.0-jre.jar
SPDXID: SPDXRef-b8e96d6d61a17df896bb04af300b83ab
FileChecksum: SHA1: 8699de25f2f979108d6c1b804a7ba38cda1116bc
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.google.guava.listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar
SPDXID: SPDXRef-d5bab7014b2caa0579ccecda09e08e06
FileChecksum: SHA1: b421526c5f297295adef1c886e5246c39d4ac629
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.google.j2objc.j2objc-annotations-3.1.jar
SPDXID: SPDXRef-e563b1c6ce4aa2fac7a07eea220a97dc
FileChecksum: SHA1: a892ca9507839bbdb900d64310ac98256cab992f
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.google.protobuf.protobuf-java-3.25.5.jar
SPDXID: SPDXRef-2f589d934febd238571a46221a894666
FileChecksum: SHA1: 5ae5c9ec39930ae9b5a61b32b93288818ec05ec1
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.h2database.h2-mvstore-2.4.240.jar
SPDXID: SPDXRef-bbaad7783e05250d613e3fab42a921dd
FileChecksum: SHA1: 94df868127cf6da07a51a3286d20c78ca050e99f
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.lihaoyi.geny_3-1.1.1.jar
SPDXID: SPDXRef-ff07ef5e2a3010e0d5dc54d6c9ae161e
FileChecksum: SHA1: 6a194169956dc7c5e64d29cec05b64da9e2fc94a
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.lihaoyi.ujson_3-4.4.2.jar
SPDXID: SPDXRef-8be91e430c95a6486b89b45f5d74fbe1
FileChecksum: SHA1: 63fa63f5d427d365a0e7ecdead023b3606553143
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.lihaoyi.upack_3-4.4.2.jar
SPDXID: SPDXRef-5ee4663c69203ae89fd39375b72194d6
FileChecksum: SHA1: 4d7a16d0a3c1376321578101b79534d1ba8dbe0a
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.lihaoyi.upickle-core_3-4.4.2.jar
SPDXID: SPDXRef-78a61165840d27428937df5e23fdffa0
FileChecksum: SHA1: 67440802a8f04d7569f56bb0e376b1ab6330a7fd
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.lihaoyi.upickle-implicits_3-4.4.2.jar
SPDXID: SPDXRef-cb8187aee7c42f40f636de29ad0f83c3
FileChecksum: SHA1: 21a7a79e1ef806723d939d8c86c3e3eeb6734f1c
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.lihaoyi.upickle_3-4.4.2.jar
SPDXID: SPDXRef-a9893024783af82d67ddb77c68411b0b
FileChecksum: SHA1: 15f7a6d05a77797f62dcc6b7e454ef2dcd32bf3b
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.michaelpollmeier.versionsort-1.0.17.jar
SPDXID: SPDXRef-6bb3e06d2a7a810bbf44137fc7f07a4e
FileChecksum: SHA1: da06c464e4e33ba699f35008183395d262fa2983
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.sun.istack.istack-commons-runtime-4.1.2.jar
SPDXID: SPDXRef-4037062a61e46def9f5938a27fab1a5e
FileChecksum: SHA1: 18ec117c85f3ba0ac65409136afa8e42bc74e739
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.thoughtworks.paranamer.paranamer-2.8.jar
SPDXID: SPDXRef-b0e3969b7ad38254816dfc80a0fbbf28
FileChecksum: SHA1: 619eba74c19ccf1da8ebec97a2d7f8ba05773dd6
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/com.typesafe.config-1.4.5.jar
SPDXID: SPDXRef-d8861d8f73accd7d66fb8640eccb7558
FileChecksum: SHA1: 0cc25b497ded7068a861517a815546fb472f9e58
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/commons-io.commons-io-2.21.0.jar
SPDXID: SPDXRef-ce03dab6c6280e1e5031273391ca8b6c
FileChecksum: SHA1: 52a6f68fe5afe335cde95461dd5c3412f04996f7
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/de.upb.cs.swt.axml-2.1.3.jar
SPDXID: SPDXRef-782ca15fecc8288cb115cb6d18f1da41
FileChecksum: SHA1: f0dff8ec1179fb893cdd7f8c52b21e047f5f3ed6
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/de.upb.cs.swt.heros-1.2.3.jar
SPDXID: SPDXRef-b9cdc1a480c66871a5aeb28372ca1e21
FileChecksum: SHA1: e90d207add1cad2157a68679b587f7770d309867
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.atom-2.5.2-classpath.jar
SPDXID: SPDXRef-3065d373ebd61e3d0ab525ae91a230b7
FileChecksum: SHA1: 7d8717f602932ac12770148c8a012459bf26035f
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.atom-2.5.2.jar
SPDXID: SPDXRef-39e5933c72f537cb1aee2802103df369
FileChecksum: SHA1: dac1eb573084611df7e2f39ee0529d8965fc14a4
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.c2cpg_3-2.5.17.jar
SPDXID: SPDXRef-caca343608935f1506ee0790d3f7b8e6
FileChecksum: SHA1: 0b417ad828abe2882a5752a332217940af9e093d
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.cpg2-domain-classes_3-2.1.6.jar
SPDXID: SPDXRef-c311b335d6a8ed3252103beed9c9e079
FileChecksum: SHA1: 857a7e273319c6a33547fbafec9be87a2083f131
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.cpg2-protos_3-2.1.6.jar
SPDXID: SPDXRef-5a63591313e86ec50e4b7331e6f046bd
FileChecksum: SHA1: 44aac50d754ae2ac55533e3c5fc0a6d0916c3c5d
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.cpg2_3-2.1.6.jar
SPDXID: SPDXRef-e4ff35d5930addf1530d8edcb0ed4389
FileChecksum: SHA1: 96de885a1933b5d07738294028d16284b061e14e
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.dataflowengineoss_3-2.5.17.jar
SPDXID: SPDXRef-d7cc306a91f4c71d66e6b81143cac554
FileChecksum: SHA1: f7d6874b2d76df786e8137ccdfe1a442aabd836b
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.javasrc2cpg_3-2.5.17.jar
SPDXID: SPDXRef-60ed8a6bd0bbcdecffbc04f0c742bea2
FileChecksum: SHA1: 754211828e02222501f5a1fb2c4f268fef063e4e
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.jimple2cpg_3-2.5.17.jar
SPDXID: SPDXRef-799391d5153ae74b60645bbf5ff44368
FileChecksum: SHA1: 8bec2247c4c4dcdd2087c98f2fbea9b97fe19395
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.jssrc2cpg_3-2.5.17.jar
SPDXID: SPDXRef-3bfeac1ee1e55c49cd11a4283e47eda7
FileChecksum: SHA1: b8d1907aac3523e20089eab13cf06fa38c9a01b2
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.odb2-core_3-2.2.1.jar
SPDXID: SPDXRef-e4b9b5bb6c8f48ebe69474687f910d93
FileChecksum: SHA1: 8411bae8acc65d93d4c47455f0e3be77a3a92897
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.odb2-formats_3-2.2.1.jar
SPDXID: SPDXRef-32b9720a593e0d232367820234be854e
FileChecksum: SHA1: 605aa2c915077c32194a4d9d0b867990e9caa642
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.odb2-traversal_3-2.2.1.jar
SPDXID: SPDXRef-a1b2e3cc2cff2229267b8525a6bc85df
FileChecksum: SHA1: 0740b73deb13ee4d6b029c12144f33fff4be8687
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.php2atom_3-2.5.17.jar
SPDXID: SPDXRef-81ddf74e94301a273ed3f25b147472aa
FileChecksum: SHA1: b8080da44a2be39f6578f547027b1cfe8e2cdb17
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.pysrc2cpg_3-2.5.17.jar
SPDXID: SPDXRef-86c5f899cd897f9fd445bd861e02eed9
FileChecksum: SHA1: 2a9e5eef259628f187ac488c05081f93671efdf4
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.ruby2atom_3-2.5.17.jar
SPDXID: SPDXRef-8a76baa8d2b42a8fe056f03ae0dd3095
FileChecksum: SHA1: 3cf0289718bd6e8e6f7d4d5ed062fd3f5f0c814e
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.semanticcpg_3-2.5.17.jar
SPDXID: SPDXRef-d2083c0f3e33b3d9729aca5ea90faa8b
FileChecksum: SHA1: 7849f18271647869208554ff309adda2ec94641d
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.appthreat.x2cpg_3-2.5.17.jar
SPDXID: SPDXRef-6f4f9df40d4bc98f230a2beb56899753
FileChecksum: SHA1: 61e656987ac8dfe8b4840aeea844969c5e718109
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.circe.circe-core_3-0.14.15.jar
SPDXID: SPDXRef-15a34575ec83f8fc1d89db6d63b3c539
FileChecksum: SHA1: 419f36ad18d898db4f9099b7c3b848cf4a70ee91
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.circe.circe-generic_3-0.14.15.jar
SPDXID: SPDXRef-ad5e1cf9bed9cff76fe63ac850777dca
FileChecksum: SHA1: 092598c81053ab0513e77cc28c2091996be06c72
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.circe.circe-jawn_3-0.14.15.jar
SPDXID: SPDXRef-6a56985bc0aa7f302363d54ac5f8084c
FileChecksum: SHA1: 1a63c86e8b25de92c23f74c9cb242187d1ebbb92
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.circe.circe-numbers_3-0.14.15.jar
SPDXID: SPDXRef-071e207ada90f05863a723896381e2e6
FileChecksum: SHA1: 159ad7a660d6d870499573689751413e9b6abcc8
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.circe.circe-parser_3-0.14.15.jar
SPDXID: SPDXRef-c4588efdd0fdd4a2bf1f64c00548e533
FileChecksum: SHA1: 3af99f3d58a59482ec4069cf2d7ed549eaa3ffcf
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/io.spray.spray-json_3-1.3.6.jar
SPDXID: SPDXRef-35d535f35588ccec87b5a29e4edd01b0
FileChecksum: SHA1: 2536de5846f836782d5ab00ab8d46c47dee80e4b
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/jakarta.activation.jakarta.activation-api-2.1.3.jar
SPDXID: SPDXRef-6e72c27a4eb78a3de2ab9d73d3df51e1
FileChecksum: SHA1: fa165bd70cda600368eee31555222776a46b881f
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/jakarta.annotation.jakarta.annotation-api-3.0.0.jar
SPDXID: SPDXRef-c1b33291eacda023f07772c5509f4c74
FileChecksum: SHA1: 54f928fadec906a99d558536756d171917b9d936
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/jakarta.xml.bind.jakarta.xml.bind-api-4.0.2.jar
SPDXID: SPDXRef-6021d6360e9f2418f11d09c687535a17
FileChecksum: SHA1: 6cd5a999b834b63238005b7144136379dc36cad2
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/net.java.dev.jna.jna-5.18.1.jar
SPDXID: SPDXRef-027002965d2e5ec1903c8ae1938d8530
FileChecksum: SHA1: b27ba04287cc4abe769642fe8318d39fc89bf937
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/net.java.dev.jna.jna-platform-5.18.1.jar
SPDXID: SPDXRef-f0364c8585346583ff9df0797b2b3d4e
FileChecksum: SHA1: dd817f391efc492041c9ae91127527c13750a789
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/net.lingala.zip4j.zip4j-2.11.5.jar
SPDXID: SPDXRef-023bcc14e5802ab957e4939c0ba55baf
FileChecksum: SHA1: 4214e396e3891cb19eded3ce5e584cba9032fdc3
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/net.sf.trove4j.core-3.1.0.jar
SPDXID: SPDXRef-aafc4d56dac194c339961cd83f2ed81d
FileChecksum: SHA1: 5fd0207b685536b29dd65c86f4b3bf89befb885c
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.antlr.antlr4-runtime-4.13.2.jar
SPDXID: SPDXRef-061520c6defebf77bfd6bae80fc8c89a
FileChecksum: SHA1: fc3db6d844df652a3d5db31c87fa12757f13691d
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.checkerframework.checker-qual-3.51.1.jar
SPDXID: SPDXRef-cf15434e16a95a07084fb52ac162b485
FileChecksum: SHA1: d69c339a293b5ec04b26c9d994cbeffb7056d122
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.angus.angus-activation-2.0.2.jar
SPDXID: SPDXRef-9b9071a3cf8daca2293581d2d206030a
FileChecksum: SHA1: 41f1e0ddd157c856926ed149ab837d110955a9fc
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.cdt.core_9.3.0.202512020204.jar
SPDXID: SPDXRef-bbfe04c97e7d4ba3024ce3d874f98ad8
FileChecksum: SHA1: d55aad524198309434f28e85a47769a785cf1954
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.platform.org.eclipse.core.contenttype-3.9.800.jar
SPDXID: SPDXRef-014c274c78572f7f869ef513b11c0ef5
FileChecksum: SHA1: 4151ef1a441039404e6e3d2b805c00c288cd822b
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.platform.org.eclipse.core.expressions-3.9.500.jar
SPDXID: SPDXRef-c704ce5c4fafcf2760a2a96d8fecb2d4
FileChecksum: SHA1: 72fb9ae9a02fb24d6d78799aa1d80f223ee048a6
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.platform.org.eclipse.core.filesystem-1.11.400.jar
SPDXID: SPDXRef-d7f0aa7aedeef4c4714be220704701ee
FileChecksum: SHA1: b5fbf4563858e95d83717dd397674ddf8786a4e3
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.platform.org.eclipse.core.jobs-3.15.700.jar
SPDXID: SPDXRef-2a8da077bd5e5dc59a2591b05267009b
FileChecksum: SHA1: b9bca244ec975304f467de46f6e14ae75948156f
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.platform.org.eclipse.core.resources-3.23.100.jar
SPDXID: SPDXRef-93897d086c4f5e2e1bef4e50956e2376
FileChecksum: SHA1: 1a51936b7616329b9ce43552ac77b9b97e389384
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.platform.org.eclipse.core.runtime-3.34.100.jar
SPDXID: SPDXRef-1c081c12a10a30589cc2980600e78ef8
FileChecksum: SHA1: 15f95e715e54a5207d1c6573554a189c75ed42ca
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.platform.org.eclipse.equinox.app-1.7.500.jar
SPDXID: SPDXRef-73eb80171923bde50a2ab1c71df66d61
FileChecksum: SHA1: 49a765430f71329008a9dfe9eb591ea0d3221f35
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.platform.org.eclipse.equinox.common-3.20.300.jar
SPDXID: SPDXRef-da5a1afe304c3bced164fd5660a4f61e
FileChecksum: SHA1: 78950bfc64c3e2c21a54227d585cbf39fb2283b5
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.platform.org.eclipse.equinox.preferences-3.12.100.jar
SPDXID: SPDXRef-1de3315b4848f2e554fa18bb210e089e
FileChecksum: SHA1: 31ec4b200952d71e06ef4546dceb8fed08fefd34
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.platform.org.eclipse.equinox.registry-3.12.600.jar
SPDXID: SPDXRef-b96e08c25d313b57d0924a3341e7305c
FileChecksum: SHA1: 0d62997e162e9ee21e957ee4d88048b83c8b34f9
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.eclipse.platform.org.eclipse.osgi-3.24.0.jar
SPDXID: SPDXRef-3deddaf82d6ef800c616952f0d141b20
FileChecksum: SHA1: 6854a92fc68561d7e51dff56ad8936d33adec974
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.functionaljava.functionaljava-4.2.jar
SPDXID: SPDXRef-4b165aabd4d2f106a64f9c4961744af7
FileChecksum: SHA1: f26bdd90a8d6b6faeb38ab2ba4c39580c1eb989f
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.glassfish.jaxb.jaxb-core-4.0.5.jar
SPDXID: SPDXRef-b36a65341b0be3fad0910d9d2dadfdb2
FileChecksum: SHA1: 007b4b11ea5542eea4ad55e1080b23be436795b3
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.glassfish.jaxb.jaxb-runtime-4.0.5.jar
SPDXID: SPDXRef-a6a1e72bcbe014c5ce845da3b9b77551
FileChecksum: SHA1: ca84c2a7169b5293e232b9d00d1e4e36d4c3914a
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.glassfish.jaxb.txw2-4.0.5.jar
SPDXID: SPDXRef-b28d316f1e3c9355777609bdb5f0153d
FileChecksum: SHA1: f36a4ef12120a9bb06d766d6a0e54b144fd7ed98
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.javassist.javassist-3.30.2-GA.jar
SPDXID: SPDXRef-9aa3973c45183dc340a3def680cb33bf
FileChecksum: SHA1: 284580b5e42dfa1b8267058566435d9e93fae7f7
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.jline.jline-reader-3.19.0.jar
SPDXID: SPDXRef-c4d390c7ace8c0d0b041c2580d3f58a4
FileChecksum: SHA1: 0645d72953711ee4e61705bc5e576fdd1f22c087
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.jline.jline-terminal-3.19.0.jar
SPDXID: SPDXRef-e9e321d3000abaf4b1a0b32e776a63aa
FileChecksum: SHA1: d4a75a8be7490c8529c029d6baa59e838f45f22e
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.jline.jline-terminal-jna-3.19.0.jar
SPDXID: SPDXRef-d2732f0b27c53dd9290011e86c374c24
FileChecksum: SHA1: c9f9071612424157ca3d5a774a42f2c9b44c10ef
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.json4s.json4s-ast_3-4.0.7.jar
SPDXID: SPDXRef-3dc12b34bc1ed919cc77d32d883ad99d
FileChecksum: SHA1: 9869333c3899d8778c4d118ca442b49bd807dcca
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.json4s.json4s-core_3-4.0.7.jar
SPDXID: SPDXRef-6335d0afe626c95f55fbfe25d81529b0
FileChecksum: SHA1: 2cd0d592872dc55d8ea2757514a38906d7b4aa3f
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.json4s.json4s-native-core_3-4.0.7.jar
SPDXID: SPDXRef-6b4512ed73b8fa7eb0cb1234ce5d7f96
FileChecksum: SHA1: 00c6dca536c471dd30fe6b675b29d6b0c876f3f8
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.json4s.json4s-native_3-4.0.7.jar
SPDXID: SPDXRef-6de046d677e15986b2d20d28feb75d71
FileChecksum: SHA1: 7d0e2d23e9c1a69339e99acd3f46696570bd157a
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.json4s.json4s-scalap_3-4.0.7.jar
SPDXID: SPDXRef-65b97baac3d02bb51860b01f7267df68
FileChecksum: SHA1: ee5ec98ccd1888cd7cf9682bf94a56a8b6e32e87
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.jspecify.jspecify-1.0.0.jar
SPDXID: SPDXRef-dd9df9d094d51936ae42b4c7b14b7080
FileChecksum: SHA1: 7425a601c1c7ec76645a78d22b8c6a627edee507
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.msgpack.msgpack-core-0.9.10.jar
SPDXID: SPDXRef-8df3bf4fcbbb59234f65dff4baac893a
FileChecksum: SHA1: e7b1aa5f73766adfd3959370f61a9598254b86ae
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.osgi.org.osgi.service.prefs-1.1.2.jar
SPDXID: SPDXRef-5837e1894fae94f7153ea277c18cf5aa
FileChecksum: SHA1: 44351fdfb119ee920394c1a27c938288c93c03c8
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.osgi.osgi.annotation-8.0.1.jar
SPDXID: SPDXRef-81ffc90806996126b41acfe49c7e160b
FileChecksum: SHA1: 593d823753aa6e128129da357d7891758e66aa1d
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.ow2.asm.asm-9.9.1.jar
SPDXID: SPDXRef-f1f2c785d7a15ddc3a9fca18139120e4
FileChecksum: SHA1: 2ceea6ab43bcae1979b2a6d85fc0ca429877e5ab
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.ow2.asm.asm-analysis-9.9.1.jar
SPDXID: SPDXRef-a81b99f8e6b82b89e54d6681d743436e
FileChecksum: SHA1: 1ab8d9316ef7a67240087919a708246c37ed1660
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.ow2.asm.asm-commons-9.7.jar
SPDXID: SPDXRef-b13168ccae4ebf1c283905bb2fb80db1
FileChecksum: SHA1: e86dda4696d3c185fcc95d8d311904e7ce38a53f
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.ow2.asm.asm-tree-9.9.1.jar
SPDXID: SPDXRef-736047b985f750bdf99a723f1b84ad92
FileChecksum: SHA1: b6b1b3366296163b4b1f540731aad0a2baa484d8
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.ow2.asm.asm-util-9.9.1.jar
SPDXID: SPDXRef-1a9fe01352594c4107738a745ea67955
FileChecksum: SHA1: e51f5b0ae0b0c1960687ae970a2a3434d39d8abb
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.projectlombok.lombok-1.18.42.jar
SPDXID: SPDXRef-4e5075349bad5d82a53a5b4b4aaa1506
FileChecksum: SHA1: 8365263844ebb62398e0dc33057ba10ba472d3b8
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.reflections.reflections-0.10.2.jar
SPDXID: SPDXRef-9cf6ad69d966e580fb674cd371533605
FileChecksum: SHA1: b638d7ca0e0fe0146b60a0e7ba232ad852a73b31
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.scala-lang.modules.scala-asm-9.9.0-scala-1.jar
SPDXID: SPDXRef-163a4d0bc8cabacd34018c48d3a09d2e
FileChecksum: SHA1: 9de6fe27c09c69521a2603b34c8dcc39c9f3b736
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.scala-lang.modules.scala-collection-compat_3-2.8.1.jar
SPDXID: SPDXRef-75a8329d8c89793a2261efb1c1cef3e6
FileChecksum: SHA1: 79d261994f2f166b9f5ab2bbd089c4731a83043d
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.scala-lang.modules.scala-parallel-collections_3-1.2.0.jar
SPDXID: SPDXRef-4f3338f309a6c503ee97bf16fa21511f
FileChecksum: SHA1: f95d62c4d0b7f3b734bf7adb9f68e416af2de4dc
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.scala-lang.modules.scala-parser-combinators_3-2.4.0.jar
SPDXID: SPDXRef-49578711dcfa6361f01f426565fa883a
FileChecksum: SHA1: 991a2c0a92ee6ad62692f71cc2e19e3f07591567
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.scala-lang.modules.scala-xml_3-2.4.0.jar
SPDXID: SPDXRef-224af8da227941b508cc027e46345c2d
FileChecksum: SHA1: b09380d0ebb77c772db3e84544f01feed61a230c
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.scala-lang.scala-library-3.8.1.jar
SPDXID: SPDXRef-81fb5daf5c6e205440d372148f2b5d22
FileChecksum: SHA1: f7c72eb837f1f76adfc27db37cbbc0ee80136e85
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.scala-lang.scala3-interfaces-3.4.1.jar
SPDXID: SPDXRef-56e22a0f77d5270591fa3c01a170bf3b
FileChecksum: SHA1: 2f6667ac2d2148b75faddf8accd33ad4ba71201a
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.scala-lang.scala3-library_3-3.8.1.jar
SPDXID: SPDXRef-1aea286ba553e8dc6738c9586d501fd6
FileChecksum: SHA1: 59725ce527f50b4775472d389a94c019f93c20e6
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.scala-lang.tasty-core_3-3.4.1.jar
SPDXID: SPDXRef-6372529ffe356b9401b94b9a2fe8e85d
FileChecksum: SHA1: f0f3ae977d428cd33522b8b225a7e791df71a367
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.scala-sbt.compiler-interface-1.9.6.jar
SPDXID: SPDXRef-7417e54b92c23b1a1bbcd0c42344f6fb
FileChecksum: SHA1: 3b8871d17259e8c94f3c0e33d033764ecb9344b8
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.scala-sbt.util-interface-1.9.8.jar
SPDXID: SPDXRef-ba176a532da27a77a65f5ecfae672af3
FileChecksum: SHA1: 66e6a0a160e445df79f9b256f66dc2bde9d6b57a
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.slf4j.slf4j-api-2.0.17.jar
SPDXID: SPDXRef-93ba4104a641e00ddad18d632594b44d
FileChecksum: SHA1: d9e58ac9c7779ba3bf8142aff6c830617a7fe60f
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.slf4j.slf4j-nop-2.0.17.jar
SPDXID: SPDXRef-1ed3b27b98647cfe19ca85d78d41f1a6
FileChecksum: SHA1: b41773047e10359aa409e7197c7624aeabfd377c
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.smali.dexlib2-2.5.2.jar
SPDXID: SPDXRef-1960a182578fc2e8aa78d35acda9c7e6
FileChecksum: SHA1: 8b664182af455b0757a7f59a42020fa5608c7d0e
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.soot-oss.soot-4.6.0.jar
SPDXID: SPDXRef-b571c112635d627e6a698eb233953bfe
FileChecksum: SHA1: 6272fe7f7710a6880a0b9ce56e231f46978b1e10
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.typelevel.cats-core_3-2.13.0.jar
SPDXID: SPDXRef-f59fcc5326862419cc1412815392ae2f
FileChecksum: SHA1: cafcdb23af26a0b2de13a1b362ae33c72fafcd6a
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.typelevel.cats-kernel_3-2.13.0.jar
SPDXID: SPDXRef-d78f1418a5acbaa56380e5b3184721d7
FileChecksum: SHA1: b54ec5e7b865852b84856f5781c7b8426d3a73a4
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/org.typelevel.jawn-parser_3-1.6.0.jar
SPDXID: SPDXRef-5eb1a2ef06611e66ccb61e154b23baa1
FileChecksum: SHA1: a89f3e40146a2afb775baafa89c7493506403856
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./lib/xmlpull.xmlpull-1.1.3.4d_b4_min.jar
SPDXID: SPDXRef-3fc748a588ff670f5900eb255ecdabc9
FileChecksum: SHA1: 6dcdbef481ff8fbac336a47048048b2b31855015
LicenseConcluded: NOASSERTION
FileCopyrightText: NONE

FileName: ./src/controllers/home_controller.cpp
SPDXID: SPDXRef-03e2e000c9caa5ea9662dc38cd0a084e
FileChecksum: SHA1: 6ee2196f27fe48aa0ead50b6e5b979d877f2b26d
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./src/controllers/system_controller.cpp
SPDXID: SPDXRef-cbfc0cb21354808975107499e3b09402
FileChecksum: SHA1: eabe1faa2ff2baa69bf8d86335ed506720ef6a3c
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./src/main.cpp
SPDXID: SPDXRef-69382af10da40683523d2b7b784a83f3
FileChecksum: SHA1: 90a2666be7df65ef8062f0dead54f83c8d197384
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./src/services/database_service.cpp
SPDXID: SPDXRef-07c3573450de4fb0780deb0d2745be85
FileChecksum: SHA1: 2e9c2bd3c9d6745c35d479231fb858ac3b42271b
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./src/services/notification_service.cpp
SPDXID: SPDXRef-fb44ea4818a310620386b5bbd2cdbbf4
FileChecksum: SHA1: 233994ca068e700a92598d5926878d4fc1cfaa09
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./src/services/smtp_service.cpp
SPDXID: SPDXRef-5caf465a694686dc6ac024d49a35a4c0
FileChecksum: SHA1: 15b5fd8974adaeea0263ccdd9eaadbbbe54e0e1c
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

FileName: ./src/utils/app_config.cpp
SPDXID: SPDXRef-9f910f95ab535fab85e984094b1031e1
FileChecksum: SHA1: 3ba8568c1c9bc17c2fb8ac036ec785e490448ac5
LicenseConcluded: NOASSERTION
LicenseInfoInFile: MIT
FileCopyrightText: <text>Copyright (C) 2026 ZHENG Robert
SPDX-FileCopyrightText: 2026 ZHENG Robert</text>

